// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const addAllProfilesToCategory = `-- name: AddAllProfilesToCategory :execrows
INSERT INTO public.user_profile_category (user_profile_id, category_id, created_at)
SELECT up.id, $1, NOW()
FROM public.user_profile up
WHERE up.is_scanned = true
AND NOT EXISTS (
    SELECT 1 FROM public.user_profile_category upc
    WHERE upc.user_profile_id = up.id AND upc.category_id = $1
)
`

func (q *Queries) AddAllProfilesToCategory(ctx context.Context, categoryID int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, addAllProfilesToCategory, categoryID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const addGroupCategory = `-- name: AddGroupCategory :exec
INSERT INTO public.group_category (group_id, category_id)
VALUES ($1, $2)
ON CONFLICT (group_id, category_id) DO NOTHING
`

type AddGroupCategoryParams struct {
	GroupID    int32 `json:"group_id"`
	CategoryID int32 `json:"category_id"`
}

func (q *Queries) AddGroupCategory(ctx context.Context, arg AddGroupCategoryParams) error {
	_, err := q.db.ExecContext(ctx, addGroupCategory, arg.GroupID, arg.CategoryID)
	return err
}

const addUserProfileCategory = `-- name: AddUserProfileCategory :exec
INSERT INTO public.user_profile_category (user_profile_id, category_id)
VALUES ($1, $2)
ON CONFLICT (user_profile_id, category_id) DO NOTHING
`

type AddUserProfileCategoryParams struct {
	UserProfileID int32 `json:"user_profile_id"`
	CategoryID    int32 `json:"category_id"`
}

func (q *Queries) AddUserProfileCategory(ctx context.Context, arg AddUserProfileCategoryParams) error {
	_, err := q.db.ExecContext(ctx, addUserProfileCategory, arg.UserProfileID, arg.CategoryID)
	return err
}

const countGeminiKeys = `-- name: CountGeminiKeys :one
SELECT COUNT(*) as total_gemini_keys FROM public.gemini_key
`

func (q *Queries) CountGeminiKeys(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGeminiKeys)
	var total_gemini_keys int64
	err := row.Scan(&total_gemini_keys)
	return total_gemini_keys, err
}

const countLogs = `-- name: CountLogs :one
SELECT COUNT(*) as total_logs FROM public.log
`

func (q *Queries) CountLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogs)
	var total_logs int64
	err := row.Scan(&total_logs)
	return total_logs, err
}

const countProfiles = `-- name: CountProfiles :one
SELECT COUNT(*) as total_profiles FROM public.user_profile WHERE is_scanned = true
`

func (q *Queries) CountProfiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProfiles)
	var total_profiles int64
	err := row.Scan(&total_profiles)
	return total_profiles, err
}

const countProfilesInCategory = `-- name: CountProfilesInCategory :one
SELECT COUNT(*) FROM public.user_profile_category WHERE category_id = $1
`

func (q *Queries) CountProfilesInCategory(ctx context.Context, categoryID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProfilesInCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrompts = `-- name: CountPrompts :one
SELECT COUNT(DISTINCT service_name) as total_prompt FROM public.prompt
`

func (q *Queries) CountPrompts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPrompts)
	var total_prompt int64
	err := row.Scan(&total_prompt)
	return total_prompt, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO public.account (email, username, password, is_block, ua, created_at, updated_at, access_token, proxy_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type CreateAccountParams struct {
	Email       string         `json:"email"`
	Username    string         `json:"username"`
	Password    string         `json:"password"`
	IsBlock     bool           `json:"is_block"`
	Ua          string         `json:"ua"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	AccessToken sql.NullString `json:"access_token"`
	ProxyID     sql.NullInt32  `json:"proxy_id"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.IsBlock,
		arg.Ua,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AccessToken,
		arg.ProxyID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO public.category (name, description, created_at, updated_at)
VALUES ($1, $2, NOW(), NOW())
RETURNING id, name, description, created_at, updated_at
`

type CreateCategoryParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, createCategory, arg.Name, arg.Description)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO public.comment (post_id, comment_id, content, created_at, author_id, is_analyzed, inserted_at)
VALUES ($1, $2, $3, $4, $5, false, NOW())
ON CONFLICT (comment_id) DO UPDATE SET
    id = EXCLUDED.id
RETURNING id, content, is_analyzed, created_at, inserted_at, post_id, author_id, comment_id
`

type CreateCommentParams struct {
	PostID    int32     `json:"post_id"`
	CommentID string    `json:"comment_id"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	AuthorID  int32     `json:"author_id"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.PostID,
		arg.CommentID,
		arg.Content,
		arg.CreatedAt,
		arg.AuthorID,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsAnalyzed,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.PostID,
		&i.AuthorID,
		&i.CommentID,
	)
	return i, err
}

const createGeminiKey = `-- name: CreateGeminiKey :one
INSERT INTO public.gemini_key (api_key)
VALUES ($1)
RETURNING id, api_key, token_used, updated_at
`

func (q *Queries) CreateGeminiKey(ctx context.Context, apiKey string) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, createGeminiKey, apiKey)
	var i GeminiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKey,
		&i.TokenUsed,
		&i.UpdatedAt,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO public."group" (group_id, group_name, is_joined, account_id)
VALUES ($1, $2, false, $3)
RETURNING id, group_id, group_name, is_joined, account_id, scanned_at
`

type CreateGroupParams struct {
	GroupID   string        `json:"group_id"`
	GroupName string        `json:"group_name"`
	AccountID sql.NullInt32 `json:"account_id"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.GroupID, arg.GroupName, arg.AccountID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const createModel = `-- name: CreateModel :one
INSERT INTO public.model (name, description, category_id, created_at)
VALUES ($1, $2, $3, NOW())
RETURNING id, name, description, created_at, category_id
`

type CreateModelParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	CategoryID  sql.NullInt32  `json:"category_id"`
}

func (q *Queries) CreateModel(ctx context.Context, arg CreateModelParams) (Model, error) {
	row := q.db.QueryRowContext(ctx, createModel, arg.Name, arg.Description, arg.CategoryID)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.CategoryID,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO public.post (post_id, content, created_at, inserted_at, group_id, is_analyzed)
VALUES ($1, $2, $3, NOW(), $4, true)
ON CONFLICT (post_id) DO UPDATE SET
    id = EXCLUDED.id
RETURNING id, post_id, content, created_at, inserted_at, group_id, is_analyzed
`

type CreatePostParams struct {
	PostID    string    `json:"post_id"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	GroupID   int32     `json:"group_id"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.PostID,
		arg.Content,
		arg.CreatedAt,
		arg.GroupID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO public.user_profile (facebook_id, name, scraped_by_id, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
ON CONFLICT (facebook_id) DO UPDATE SET
    id = EXCLUDED.id
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

type CreateProfileParams struct {
	FacebookID  string         `json:"facebook_id"`
	Name        sql.NullString `json:"name"`
	ScrapedByID int32          `json:"scraped_by_id"`
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, createProfile, arg.FacebookID, arg.Name, arg.ScrapedByID)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const createPrompt = `-- name: CreatePrompt :one
WITH next_version AS (
  SELECT COALESCE(MAX(version), 0) + 1 AS version
  FROM public.prompt
  WHERE service_name = $1 AND category_id = $4
)
INSERT INTO public.prompt (service_name, version, content, created_by, created_at, category_id)
SELECT $1, next_version.version, $2, $3, NOW(), $4
FROM next_version
RETURNING id, content, service_name, version, created_by, created_at, category_id
`

type CreatePromptParams struct {
	ServiceName string `json:"service_name"`
	Content     string `json:"content"`
	CreatedBy   string `json:"created_by"`
	CategoryID  int32  `json:"category_id"`
}

func (q *Queries) CreatePrompt(ctx context.Context, arg CreatePromptParams) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, createPrompt,
		arg.ServiceName,
		arg.Content,
		arg.CreatedBy,
		arg.CategoryID,
	)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.CategoryID,
	)
	return i, err
}

const createRequest = `-- name: CreateRequest :one
INSERT INTO public.request(description)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateRequest(ctx context.Context, description sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, createRequest, description)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAccounts = `-- name: DeleteAccounts :exec
DELETE FROM public.account WHERE id = ANY($1::int[])
`

func (q *Queries) DeleteAccounts(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccounts, pq.Array(dollar_1))
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM public.category WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteGeminiKey = `-- name: DeleteGeminiKey :exec
DELETE FROM public.gemini_key WHERE id = $1
`

func (q *Queries) DeleteGeminiKey(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGeminiKey, id)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
WITH deleted_posts AS (
  DELETE FROM public.post WHERE group_id = $1 RETURNING post.id
),
deleted_comments AS (
  DELETE FROM public.comment WHERE post_id IN (SELECT id FROM deleted_posts)
)
DELETE FROM public."group" WHERE "group".id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deleteGroupCategory = `-- name: DeleteGroupCategory :exec
DELETE FROM public.group_category WHERE group_id = $1 AND category_id = $2
`

type DeleteGroupCategoryParams struct {
	GroupID    int32 `json:"group_id"`
	CategoryID int32 `json:"category_id"`
}

func (q *Queries) DeleteGroupCategory(ctx context.Context, arg DeleteGroupCategoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteGroupCategory, arg.GroupID, arg.CategoryID)
	return err
}

const deleteJunkProfiles = `-- name: DeleteJunkProfiles :one
WITH non_null_count AS (
  SELECT up.id,
    (COALESCE(up.bio, '') != '')::int +
    (COALESCE(up.location, '') != '')::int +
    (COALESCE(up.work, '') != '')::int +
    (COALESCE(up.locale, '') != '')::int +
    (COALESCE(up.education, '') != '')::int +
    (COALESCE(up.relationship_status, '') != '')::int +
    (COALESCE(up.hometown, '') != '')::int +
    (COALESCE(up.gender, '') != '')::int +
    (COALESCE(up.birthday, '') != '')::int +
    (COALESCE(up.email, '') != '')::int +
    (COALESCE(up.phone, '') != '')::int AS field_count
  FROM public.user_profile up
),
profiles_to_delete AS (
  SELECT nnc.id 
  FROM non_null_count nnc
  JOIN public.user_profile up ON nnc.id = up.id
  WHERE
    up.is_scanned = true
    AND (up.name = ''
    OR up.name IS NULL
    OR up.name LIKE '%Anonymous%' 
    OR up.name LIKE '%anonymous%' 
    OR up.name LIKE '%ẩn danh%'
    OR up.name LIKE '%Ẩn danh%'
    OR nnc.field_count < 1)
),
deleted_comments AS (
  DELETE FROM public.comment 
  WHERE author_id IN (SELECT id FROM profiles_to_delete)
  RETURNING author_id
),
deleted_profiles AS (
  DELETE FROM public.user_profile 
  WHERE id IN (SELECT id FROM profiles_to_delete)
  RETURNING id
)
SELECT COUNT(*) as deleted_count FROM deleted_profiles
`

func (q *Queries) DeleteJunkProfiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteJunkProfiles)
	var deleted_count int64
	err := row.Scan(&deleted_count)
	return deleted_count, err
}

const deleteModel = `-- name: DeleteModel :exec
DELETE FROM public.model WHERE id = $1
`

func (q *Queries) DeleteModel(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteModel, id)
	return err
}

const deletePrompt = `-- name: DeletePrompt :exec
WITH prompt_to_delete AS (
  SELECT id, content, service_name, version, created_by, created_at, category_id FROM public.prompt d WHERE d.id = $1
)
DELETE FROM public.prompt WHERE service_name = (SELECT service_name FROM prompt_to_delete) AND category_id = (SELECT category_id FROM prompt_to_delete)
`

func (q *Queries) DeletePrompt(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePrompt, id)
	return err
}

const findSimilarProfiles = `-- name: FindSimilarProfiles :many
SELECT
  p.id AS profile_id,
  p.profile_url as profile_url,
  p.name AS profile_name,
  CAST(1 - (ep.embedding <=> (
	SELECT embedding FROM public.embedded_profile WHERE embedded_profile.pid = $1
  )) AS DOUBLE PRECISION) AS similarity
FROM embedded_profile ep
JOIN user_profile p ON p.id = ep.pid
WHERE ep.pid != $1
ORDER BY ep.embedding <=> (
	SELECT embedding FROM public.embedded_profile WHERE embedded_profile.pid = $1
  )
LIMIT $2
`

type FindSimilarProfilesParams struct {
	Pid   int32 `json:"pid"`
	Limit int32 `json:"limit"`
}

type FindSimilarProfilesRow struct {
	ProfileID   int32          `json:"profile_id"`
	ProfileUrl  string         `json:"profile_url"`
	ProfileName sql.NullString `json:"profile_name"`
	Similarity  float64        `json:"similarity"`
}

func (q *Queries) FindSimilarProfiles(ctx context.Context, arg FindSimilarProfilesParams) ([]FindSimilarProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, findSimilarProfiles, arg.Pid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindSimilarProfilesRow
	for rows.Next() {
		var i FindSimilarProfilesRow
		if err := rows.Scan(
			&i.ProfileID,
			&i.ProfileUrl,
			&i.ProfileName,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountById = `-- name: GetAccountById :one
SELECT id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id FROM public.account WHERE id = $1
`

func (q *Queries) GetAccountById(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const getAccountStats = `-- name: GetAccountStats :one
SELECT
  (SELECT COUNT(*) FROM public.account) AS total_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = false and access_token IS NOT NULL) AS active_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = true) AS blocked_accounts
`

type GetAccountStatsRow struct {
	TotalAccounts   int64 `json:"total_accounts"`
	ActiveAccounts  int64 `json:"active_accounts"`
	BlockedAccounts int64 `json:"blocked_accounts"`
}

func (q *Queries) GetAccountStats(ctx context.Context) (GetAccountStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountStats)
	var i GetAccountStatsRow
	err := row.Scan(&i.TotalAccounts, &i.ActiveAccounts, &i.BlockedAccounts)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT a.id, a.username, a.email, a.updated_at, a.access_token, (
	SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id
) as group_count, COOKIES IS NOT NULL as is_login,
a.is_block
FROM public.account a LIMIT $1 OFFSET $2
`

type GetAccountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAccountsRow struct {
	ID          int32          `json:"id"`
	Username    string         `json:"username"`
	Email       string         `json:"email"`
	UpdatedAt   time.Time      `json:"updated_at"`
	AccessToken sql.NullString `json:"access_token"`
	GroupCount  int64          `json:"group_count"`
	IsLogin     interface{}    `json:"is_login"`
	IsBlock     bool           `json:"is_block"`
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]GetAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.GroupCount,
			&i.IsLogin,
			&i.IsBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllConfigs = `-- name: GetAllConfigs :many
SELECT id, key, value FROM public.config
`

func (q *Queries) GetAllConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.db.QueryContext(ctx, getAllConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(&i.ID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPrompts = `-- name: GetAllPrompts :many
SELECT id, content, service_name, version, created_by, created_at, category_id, rn
FROM (
  SELECT id, content, service_name, version, created_by, created_at, category_id, ROW_NUMBER() OVER (PARTITION BY service_name ORDER BY version DESC) AS rn
  FROM public.prompt
) t
WHERE rn = 1
ORDER BY service_name
LIMIT $1 OFFSET $2
`

type GetAllPromptsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllPromptsRow struct {
	ID          int32     `json:"id"`
	Content     string    `json:"content"`
	ServiceName string    `json:"service_name"`
	Version     int32     `json:"version"`
	CreatedBy   string    `json:"created_by"`
	CreatedAt   time.Time `json:"created_at"`
	CategoryID  int32     `json:"category_id"`
	Rn          int64     `json:"rn"`
}

func (q *Queries) GetAllPrompts(ctx context.Context, arg GetAllPromptsParams) ([]GetAllPromptsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPrompts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPromptsRow
	for rows.Next() {
		var i GetAllPromptsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.ServiceName,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.CategoryID,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT id, name, description, created_at, updated_at FROM public.category ORDER BY name
`

func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, description, created_at, updated_at FROM public.category WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id int32) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConfigByKey = `-- name: GetConfigByKey :one
SELECT id, key, value FROM public.config WHERE "key" = $1
`

func (q *Queries) GetConfigByKey(ctx context.Context, key string) (Config, error) {
	row := q.db.QueryRowContext(ctx, getConfigByKey, key)
	var i Config
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const getDashboardStats = `-- name: GetDashboardStats :one
SELECT
  (SELECT COUNT(*) FROM public."group") AS total_groups,
  (SELECT COUNT(*) FROM public.comment) AS total_comments,
  (SELECT COUNT(*) FROM public.post) AS total_posts,
  (SELECT COUNT(*) FROM public.user_profile) AS total_profiles,
  (SELECT COUNT(*) FROM public.embedded_profile) AS embedded_count,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_scanned = true) AS scanned_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE model_score IS NOT NULL) AS scored_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_analyzed = true) AS analyzed_profiles,
  (SELECT COUNT(*) FROM public.account) AS total_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = false and access_token IS NOT NULL) AS active_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = true) AS blocked_accounts
`

type GetDashboardStatsRow struct {
	TotalGroups      int64 `json:"total_groups"`
	TotalComments    int64 `json:"total_comments"`
	TotalPosts       int64 `json:"total_posts"`
	TotalProfiles    int64 `json:"total_profiles"`
	EmbeddedCount    int64 `json:"embedded_count"`
	ScannedProfiles  int64 `json:"scanned_profiles"`
	ScoredProfiles   int64 `json:"scored_profiles"`
	AnalyzedProfiles int64 `json:"analyzed_profiles"`
	TotalAccounts    int64 `json:"total_accounts"`
	ActiveAccounts   int64 `json:"active_accounts"`
	BlockedAccounts  int64 `json:"blocked_accounts"`
}

func (q *Queries) GetDashboardStats(ctx context.Context) (GetDashboardStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardStats)
	var i GetDashboardStatsRow
	err := row.Scan(
		&i.TotalGroups,
		&i.TotalComments,
		&i.TotalPosts,
		&i.TotalProfiles,
		&i.EmbeddedCount,
		&i.ScannedProfiles,
		&i.ScoredProfiles,
		&i.AnalyzedProfiles,
		&i.TotalAccounts,
		&i.ActiveAccounts,
		&i.BlockedAccounts,
	)
	return i, err
}

const getGeminiKeyForUse = `-- name: GetGeminiKeyForUse :one
SELECT id, api_key, token_used, updated_at FROM public.gemini_key ORDER BY updated_at ASC NULLS FIRST LIMIT 1
`

func (q *Queries) GetGeminiKeyForUse(ctx context.Context) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, getGeminiKeyForUse)
	var i GeminiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKey,
		&i.TokenUsed,
		&i.UpdatedAt,
	)
	return i, err
}

const getGeminiKeys = `-- name: GetGeminiKeys :many
SELECT id, api_key, token_used, updated_at FROM public.gemini_key
`

func (q *Queries) GetGeminiKeys(ctx context.Context) ([]GeminiKey, error) {
	rows, err := q.db.QueryContext(ctx, getGeminiKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeminiKey
	for rows.Next() {
		var i GeminiKey
		if err := rows.Scan(
			&i.ID,
			&i.ApiKey,
			&i.TokenUsed,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupCategories = `-- name: GetGroupCategories :many
SELECT c.id, c.name, c.description, c.created_at, c.updated_at FROM public.category c
JOIN public.group_category gc ON c.id = gc.category_id
WHERE gc.group_id = $1
`

func (q *Queries) GetGroupCategories(ctx context.Context, groupID int32) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getGroupCategories, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsByAccountId = `-- name: GetGroupsByAccountId :many
SELECT id, group_id, group_name, is_joined, account_id, scanned_at, COALESCE((
  SELECT json_agg(c) FROM public.category c
  JOIN public.group_category gc ON c.id = gc.category_id
  WHERE gc.group_id = g.id
), '[]'::json)::jsonb as categories FROM public."group" g WHERE account_id = $1
`

type GetGroupsByAccountIdRow struct {
	ID         int32         `json:"id"`
	GroupID    string        `json:"group_id"`
	GroupName  string        `json:"group_name"`
	IsJoined   bool          `json:"is_joined"`
	AccountID  sql.NullInt32 `json:"account_id"`
	ScannedAt  sql.NullTime  `json:"scanned_at"`
	Categories NullableJSON  `json:"categories"`
}

func (q *Queries) GetGroupsByAccountId(ctx context.Context, accountID sql.NullInt32) ([]GetGroupsByAccountIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsByAccountIdRow
	for rows.Next() {
		var i GetGroupsByAccountIdRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
			&i.Categories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsToScan = `-- name: GetGroupsToScan :many
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.access_token, COALESCE((
  SELECT json_agg(c) FROM public.category c
  JOIN public.group_category gc ON c.id = gc.category_id
  WHERE gc.group_id = g.id
), '[]'::json)::jsonb as categories FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.is_joined = true AND g.account_id = $1
ORDER BY scanned_at ASC NULLS FIRST LIMIT $2
`

type GetGroupsToScanParams struct {
	AccountID sql.NullInt32 `json:"account_id"`
	Limit     int32         `json:"limit"`
}

type GetGroupsToScanRow struct {
	ID          int32          `json:"id"`
	GroupID     string         `json:"group_id"`
	GroupName   string         `json:"group_name"`
	IsJoined    bool           `json:"is_joined"`
	AccountID   sql.NullInt32  `json:"account_id"`
	ScannedAt   sql.NullTime   `json:"scanned_at"`
	AccessToken sql.NullString `json:"access_token"`
	Categories  NullableJSON   `json:"categories"`
}

func (q *Queries) GetGroupsToScan(ctx context.Context, arg GetGroupsToScanParams) ([]GetGroupsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsToScanRow
	for rows.Next() {
		var i GetGroupsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
			&i.AccessToken,
			&i.Categories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogs = `-- name: GetLogs :many
SELECT l.id, l.account_id, l.action, l.target_id, l.description, l.created_at, a.username FROM public.log l
LEFT JOIN public.account a ON l.account_id = a.id
ORDER BY l.created_at DESC
LIMIT $1 OFFSET $2
`

type GetLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetLogsRow struct {
	ID          int32          `json:"id"`
	AccountID   sql.NullInt32  `json:"account_id"`
	Action      string         `json:"action"`
	TargetID    sql.NullInt32  `json:"target_id"`
	Description sql.NullString `json:"description"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	Username    sql.NullString `json:"username"`
}

func (q *Queries) GetLogs(ctx context.Context, arg GetLogsParams) ([]GetLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogsRow
	for rows.Next() {
		var i GetLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Action,
			&i.TargetID,
			&i.Description,
			&i.CreatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelByCategory = `-- name: GetModelByCategory :one
SELECT id, name, description, created_at, category_id FROM public.model WHERE category_id = $1
`

func (q *Queries) GetModelByCategory(ctx context.Context, categoryID sql.NullInt32) (Model, error) {
	row := q.db.QueryRowContext(ctx, getModelByCategory, categoryID)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.CategoryID,
	)
	return i, err
}

const getModelByID = `-- name: GetModelByID :one
SELECT id, name, description, created_at, category_id FROM public.model WHERE id = $1
`

func (q *Queries) GetModelByID(ctx context.Context, id int32) (Model, error) {
	row := q.db.QueryRowContext(ctx, getModelByID, id)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.CategoryID,
	)
	return i, err
}

const getModels = `-- name: GetModels :many
SELECT id, name, description, created_at, category_id FROM public.model
ORDER BY created_at DESC
`

// Model Management queries
func (q *Queries) GetModels(ctx context.Context) ([]Model, error) {
	rows, err := q.db.QueryContext(ctx, getModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelsWithoutCategory = `-- name: GetModelsWithoutCategory :many
SELECT id, name, description, created_at, category_id FROM public.model WHERE category_id IS NULL ORDER BY created_at DESC
`

func (q *Queries) GetModelsWithoutCategory(ctx context.Context) ([]Model, error) {
	rows, err := q.db.QueryContext(ctx, getModelsWithoutCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOKAccountIds = `-- name: GetOKAccountIds :many
SELECT t.id
FROM (SELECT a.id,
  (SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id) AS group_count
  FROM public.account a
  WHERE a.is_block = false AND a.access_token IS NOT NULL
) t
WHERE t.group_count > 0
`

func (q *Queries) GetOKAccountIds(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getOKAccountIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileById = `-- name: GetProfileById :one
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score, COALESCE((SELECT json_agg(c) FROM public.user_profile_category c WHERE c.user_profile_id = up.id), '[]'::json)::jsonb as categories
FROM public.user_profile up WHERE id = $1
`

type GetProfileByIdRow struct {
	ID                 int32           `json:"id"`
	FacebookID         string          `json:"facebook_id"`
	Name               sql.NullString  `json:"name"`
	Bio                sql.NullString  `json:"bio"`
	Location           sql.NullString  `json:"location"`
	Work               sql.NullString  `json:"work"`
	Education          sql.NullString  `json:"education"`
	RelationshipStatus sql.NullString  `json:"relationship_status"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
	ScrapedByID        int32           `json:"scraped_by_id"`
	IsScanned          bool            `json:"is_scanned"`
	Hometown           sql.NullString  `json:"hometown"`
	Locale             string          `json:"locale"`
	Gender             sql.NullString  `json:"gender"`
	Birthday           sql.NullString  `json:"birthday"`
	Email              sql.NullString  `json:"email"`
	Phone              sql.NullString  `json:"phone"`
	ProfileUrl         string          `json:"profile_url"`
	IsAnalyzed         sql.NullBool    `json:"is_analyzed"`
	GeminiScore        sql.NullFloat64 `json:"gemini_score"`
	ModelScore         sql.NullFloat64 `json:"model_score"`
	Categories         NullableJSON    `json:"categories"`
}

func (q *Queries) GetProfileById(ctx context.Context, id int32) (GetProfileByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileById, id)
	var i GetProfileByIdRow
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
		&i.Categories,
	)
	return i, err
}

const getProfileEmbedding = `-- name: GetProfileEmbedding :one
SELECT embedding FROM public.embedded_profile WHERE pid = $1
`

func (q *Queries) GetProfileEmbedding(ctx context.Context, pid int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getProfileEmbedding, pid)
	var embedding interface{}
	err := row.Scan(&embedding)
	return embedding, err
}

const getProfileIDForEmbedding = `-- name: GetProfileIDForEmbedding :many
SELECT up.id FROM public.user_profile up
JOIN public.user_profile_category upc ON up.id = upc.user_profile_id
WHERE up.id NOT IN (
  SELECT pid FROM public.embedded_profile
) AND up.is_scanned = true 
AND upc.category_id = $1
LIMIT $2
`

type GetProfileIDForEmbeddingParams struct {
	CategoryID int32 `json:"category_id"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) GetProfileIDForEmbedding(ctx context.Context, arg GetProfileIDForEmbeddingParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getProfileIDForEmbedding, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileStats = `-- name: GetProfileStats :one
SELECT
  (SELECT COUNT(*) FROM public.user_profile) AS total_profiles,
  (SELECT COUNT(*) FROM public.embedded_profile) AS embedded_count,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_scanned = true) AS scanned_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE model_score IS NOT NULL) AS scored_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_analyzed = true) AS analyzed_profiles
`

type GetProfileStatsRow struct {
	TotalProfiles    int64 `json:"total_profiles"`
	EmbeddedCount    int64 `json:"embedded_count"`
	ScannedProfiles  int64 `json:"scanned_profiles"`
	ScoredProfiles   int64 `json:"scored_profiles"`
	AnalyzedProfiles int64 `json:"analyzed_profiles"`
}

func (q *Queries) GetProfileStats(ctx context.Context) (GetProfileStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileStats)
	var i GetProfileStatsRow
	err := row.Scan(
		&i.TotalProfiles,
		&i.EmbeddedCount,
		&i.ScannedProfiles,
		&i.ScoredProfiles,
		&i.AnalyzedProfiles,
	)
	return i, err
}

const getProfilesAnalysisCronjob = `-- name: GetProfilesAnalysisCronjob :many
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, up.is_analyzed, up.gemini_score, up.model_score,
  upc.category_id,
  (COALESCE(up.bio, '') != '')::int +
  (COALESCE(up.location, '') != '')::int +
  (COALESCE(up.work, '') != '')::int +
  (COALESCE(up.locale, '') != '')::int +
  (COALESCE(up.education, '') != '')::int +
  (COALESCE(up.relationship_status, '') != '')::int +
  (COALESCE(up.hometown, '') != '')::int +
  (COALESCE(up.gender, '') != '')::int +
  (COALESCE(up.birthday, '') != '')::int +
  (COALESCE(up.email, '') != '')::int +
  (COALESCE(up.phone, '') != '')::int AS non_null_count
FROM public.user_profile up
JOIN public.user_profile_category upc ON up.id = upc.user_profile_id
WHERE up.is_scanned = true AND up.is_analyzed = false
AND upc.category_id = $1
ORDER BY non_null_count DESC, up.updated_at ASC
LIMIT $2
`

type GetProfilesAnalysisCronjobParams struct {
	CategoryID int32 `json:"category_id"`
	Limit      int32 `json:"limit"`
}

type GetProfilesAnalysisCronjobRow struct {
	ID                 int32           `json:"id"`
	FacebookID         string          `json:"facebook_id"`
	Name               sql.NullString  `json:"name"`
	Bio                sql.NullString  `json:"bio"`
	Location           sql.NullString  `json:"location"`
	Work               sql.NullString  `json:"work"`
	Education          sql.NullString  `json:"education"`
	RelationshipStatus sql.NullString  `json:"relationship_status"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
	ScrapedByID        int32           `json:"scraped_by_id"`
	IsScanned          bool            `json:"is_scanned"`
	Hometown           sql.NullString  `json:"hometown"`
	Locale             string          `json:"locale"`
	Gender             sql.NullString  `json:"gender"`
	Birthday           sql.NullString  `json:"birthday"`
	Email              sql.NullString  `json:"email"`
	Phone              sql.NullString  `json:"phone"`
	ProfileUrl         string          `json:"profile_url"`
	IsAnalyzed         sql.NullBool    `json:"is_analyzed"`
	GeminiScore        sql.NullFloat64 `json:"gemini_score"`
	ModelScore         sql.NullFloat64 `json:"model_score"`
	CategoryID         int32           `json:"category_id"`
	NonNullCount       int32           `json:"non_null_count"`
}

func (q *Queries) GetProfilesAnalysisCronjob(ctx context.Context, arg GetProfilesAnalysisCronjobParams) ([]GetProfilesAnalysisCronjobRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesAnalysisCronjob, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesAnalysisCronjobRow
	for rows.Next() {
		var i GetProfilesAnalysisCronjobRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.CategoryID,
			&i.NonNullCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesAnalysisPage = `-- name: GetProfilesAnalysisPage :many
SELECT 
  up.id,
  up.facebook_id,
  up.name,
  up.is_analyzed,
  up.gemini_score,
  up.model_score,
  (COALESCE((
    SELECT json_agg(json_build_object('id', c.id, 'name', c.name, 'description', c.description))
    FROM public.user_profile_category upc
    JOIN public.category c ON c.id = upc.category_id
    WHERE upc.user_profile_id = up.id
  ), '[]'::json))::jsonb as categories,
  ((COALESCE(up.bio, '') != '')::int +
  (COALESCE(up.location, '') != '')::int +
  (COALESCE(up.work, '') != '')::int +
  (COALESCE(up.locale, '') != '')::int +
  (COALESCE(up.education, '') != '')::int +
  (COALESCE(up.relationship_status, '') != '')::int +
  (COALESCE(up.hometown, '') != '')::int +
  (COALESCE(up.gender, '') != '')::int +
  (COALESCE(up.birthday, '') != '')::int +
  (COALESCE(up.email, '') != '')::int +
  (COALESCE(up.phone, '') != '')::int)::int AS non_null_count
FROM public.user_profile up
WHERE up.is_scanned = true
ORDER BY up.model_score DESC NULLS LAST, up.gemini_score DESC NULLS LAST, non_null_count DESC, up.updated_at ASC
LIMIT $1 OFFSET $2
`

type GetProfilesAnalysisPageParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProfilesAnalysisPageRow struct {
	ID           int32           `json:"id"`
	FacebookID   string          `json:"facebook_id"`
	Name         sql.NullString  `json:"name"`
	IsAnalyzed   sql.NullBool    `json:"is_analyzed"`
	GeminiScore  sql.NullFloat64 `json:"gemini_score"`
	ModelScore   sql.NullFloat64 `json:"model_score"`
	Categories   NullableJSON    `json:"categories"`
	NonNullCount int32           `json:"non_null_count"`
}

func (q *Queries) GetProfilesAnalysisPage(ctx context.Context, arg GetProfilesAnalysisPageParams) ([]GetProfilesAnalysisPageRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesAnalysisPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesAnalysisPageRow
	for rows.Next() {
		var i GetProfilesAnalysisPageRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.Categories,
			&i.NonNullCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesForExport = `-- name: GetProfilesForExport :many
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, up.is_analyzed, up.gemini_score, up.model_score, ep.embedding FROM public.user_profile up
JOIN public.embedded_profile ep ON up.id = ep.pid
`

type GetProfilesForExportRow struct {
	ID                 int32           `json:"id"`
	FacebookID         string          `json:"facebook_id"`
	Name               sql.NullString  `json:"name"`
	Bio                sql.NullString  `json:"bio"`
	Location           sql.NullString  `json:"location"`
	Work               sql.NullString  `json:"work"`
	Education          sql.NullString  `json:"education"`
	RelationshipStatus sql.NullString  `json:"relationship_status"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
	ScrapedByID        int32           `json:"scraped_by_id"`
	IsScanned          bool            `json:"is_scanned"`
	Hometown           sql.NullString  `json:"hometown"`
	Locale             string          `json:"locale"`
	Gender             sql.NullString  `json:"gender"`
	Birthday           sql.NullString  `json:"birthday"`
	Email              sql.NullString  `json:"email"`
	Phone              sql.NullString  `json:"phone"`
	ProfileUrl         string          `json:"profile_url"`
	IsAnalyzed         sql.NullBool    `json:"is_analyzed"`
	GeminiScore        sql.NullFloat64 `json:"gemini_score"`
	ModelScore         sql.NullFloat64 `json:"model_score"`
	Embedding          interface{}     `json:"embedding"`
}

func (q *Queries) GetProfilesForExport(ctx context.Context) ([]GetProfilesForExportRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesForExport)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesForExportRow
	for rows.Next() {
		var i GetProfilesForExportRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesForScoring = `-- name: GetProfilesForScoring :many
SELECT up.id FROM public.user_profile up
JOIN public.embedded_profile ep ON up.id = ep.pid
JOIN public.user_profile_category upc ON up.id = upc.user_profile_id
WHERE up.is_scanned = true AND up.model_score IS NULL
AND upc.category_id = $1
LIMIT $2
`

type GetProfilesForScoringParams struct {
	CategoryID int32 `json:"category_id"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) GetProfilesForScoring(ctx context.Context, arg GetProfilesForScoringParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesForScoring, arg.CategoryID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesToScan = `-- name: GetProfilesToScan :many
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, up.is_analyzed, up.gemini_score, up.model_score, a.access_token, a.id as account_id
FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.is_scanned = false AND a.is_block = false AND a.access_token IS NOT NULL
ORDER BY up.updated_at ASC LIMIT $1
`

type GetProfilesToScanRow struct {
	ID                 int32           `json:"id"`
	FacebookID         string          `json:"facebook_id"`
	Name               sql.NullString  `json:"name"`
	Bio                sql.NullString  `json:"bio"`
	Location           sql.NullString  `json:"location"`
	Work               sql.NullString  `json:"work"`
	Education          sql.NullString  `json:"education"`
	RelationshipStatus sql.NullString  `json:"relationship_status"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
	ScrapedByID        int32           `json:"scraped_by_id"`
	IsScanned          bool            `json:"is_scanned"`
	Hometown           sql.NullString  `json:"hometown"`
	Locale             string          `json:"locale"`
	Gender             sql.NullString  `json:"gender"`
	Birthday           sql.NullString  `json:"birthday"`
	Email              sql.NullString  `json:"email"`
	Phone              sql.NullString  `json:"phone"`
	ProfileUrl         string          `json:"profile_url"`
	IsAnalyzed         sql.NullBool    `json:"is_analyzed"`
	GeminiScore        sql.NullFloat64 `json:"gemini_score"`
	ModelScore         sql.NullFloat64 `json:"model_score"`
	AccessToken        sql.NullString  `json:"access_token"`
	AccountID          int32           `json:"account_id"`
}

func (q *Queries) GetProfilesToScan(ctx context.Context, limit int32) ([]GetProfilesToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesToScan, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesToScanRow
	for rows.Next() {
		var i GetProfilesToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.AccessToken,
			&i.AccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrompt = `-- name: GetPrompt :one
SELECT id, content, service_name, version, created_by, created_at, category_id FROM public.prompt
WHERE service_name = $1 AND category_id = $2
ORDER BY version DESC LIMIT 1
`

type GetPromptParams struct {
	ServiceName string `json:"service_name"`
	CategoryID  int32  `json:"category_id"`
}

func (q *Queries) GetPrompt(ctx context.Context, arg GetPromptParams) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, getPrompt, arg.ServiceName, arg.CategoryID)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.CategoryID,
	)
	return i, err
}

const getPromptsByCategory = `-- name: GetPromptsByCategory :many
SELECT id, content, service_name, version, created_by, created_at, category_id, rn
FROM (
  SELECT id, content, service_name, version, created_by, created_at, category_id, ROW_NUMBER() OVER (PARTITION BY service_name ORDER BY version DESC) AS rn
  FROM public.prompt WHERE category_id = $3
) t
WHERE rn = 1
ORDER BY service_name
LIMIT $1 OFFSET $2
`

type GetPromptsByCategoryParams struct {
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	CategoryID int32 `json:"category_id"`
}

type GetPromptsByCategoryRow struct {
	ID          int32     `json:"id"`
	Content     string    `json:"content"`
	ServiceName string    `json:"service_name"`
	Version     int32     `json:"version"`
	CreatedBy   string    `json:"created_by"`
	CreatedAt   time.Time `json:"created_at"`
	CategoryID  int32     `json:"category_id"`
	Rn          int64     `json:"rn"`
}

func (q *Queries) GetPromptsByCategory(ctx context.Context, arg GetPromptsByCategoryParams) ([]GetPromptsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPromptsByCategory, arg.Limit, arg.Offset, arg.CategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPromptsByCategoryRow
	for rows.Next() {
		var i GetPromptsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.ServiceName,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.CategoryID,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestById = `-- name: GetRequestById :one
SELECT id, progress, status, description, created_at, updated_at, error_message FROM public.request WHERE id = $1
`

func (q *Queries) GetRequestById(ctx context.Context, id int32) (Request, error) {
	row := q.db.QueryRowContext(ctx, getRequestById, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Progress,
		&i.Status,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getScoreDistribution = `-- name: GetScoreDistribution :many
WITH score_ranges AS (
  SELECT '0.0-0.2' as range UNION ALL
  SELECT '0.2-0.4' UNION ALL
  SELECT '0.4-0.6' UNION ALL
  SELECT '0.6-0.8' UNION ALL
  SELECT '0.8-1.0'
),
gemini_counts AS (
  SELECT
    CASE 
      WHEN gemini_score BETWEEN 0.0 AND 0.2 THEN '0.0-0.2'
      WHEN gemini_score BETWEEN 0.2 AND 0.4 THEN '0.2-0.4'
      WHEN gemini_score BETWEEN 0.4 AND 0.6 THEN '0.4-0.6'
      WHEN gemini_score BETWEEN 0.6 AND 0.8 THEN '0.6-0.8'
      WHEN gemini_score BETWEEN 0.8 AND 1.0 THEN '0.8-1.0'
    END as score_range,
    COUNT(*) as gemini_count
  FROM public.user_profile
  WHERE gemini_score IS NOT NULL
  GROUP BY score_range
),
model_counts AS (
  SELECT
    CASE 
      WHEN model_score BETWEEN 0.0 AND 0.2 THEN '0.0-0.2'
      WHEN model_score BETWEEN 0.2 AND 0.4 THEN '0.2-0.4'
      WHEN model_score BETWEEN 0.4 AND 0.6 THEN '0.4-0.6'
      WHEN model_score BETWEEN 0.6 AND 0.8 THEN '0.6-0.8'
      WHEN model_score BETWEEN 0.8 AND 1.0 THEN '0.8-1.0'
    END as score_range,
    COUNT(*) as model_count
  FROM public.user_profile
  WHERE model_score IS NOT NULL
  GROUP BY score_range
)
SELECT 
  sr.range as score_range,
  COALESCE(gc.gemini_count, 0) as gemini_count,
  COALESCE(mc.model_count, 0) as model_count
FROM score_ranges sr
LEFT JOIN gemini_counts gc ON sr.range = gc.score_range
LEFT JOIN model_counts mc ON sr.range = mc.score_range
ORDER BY sr.range
`

type GetScoreDistributionRow struct {
	ScoreRange  string `json:"score_range"`
	GeminiCount int64  `json:"gemini_count"`
	ModelCount  int64  `json:"model_count"`
}

func (q *Queries) GetScoreDistribution(ctx context.Context) ([]GetScoreDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getScoreDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoreDistributionRow
	for rows.Next() {
		var i GetScoreDistributionRow
		if err := rows.Scan(&i.ScoreRange, &i.GeminiCount, &i.ModelCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStats = `-- name: GetStats :one
SELECT
  (SELECT COUNT(*) FROM public."group") AS total_groups,
  (SELECT COUNT(*) FROM public.comment) AS total_comments,
  (SELECT COUNT(*) FROM public.post) AS total_posts
`

type GetStatsRow struct {
	TotalGroups   int64 `json:"total_groups"`
	TotalComments int64 `json:"total_comments"`
	TotalPosts    int64 `json:"total_posts"`
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(&i.TotalGroups, &i.TotalComments, &i.TotalPosts)
	return i, err
}

const getTimeSeriesData = `-- name: GetTimeSeriesData :many
SELECT 
  DATE_TRUNC('day', updated_at)::date as date,
  COUNT(*) as count
FROM public.user_profile 
WHERE updated_at >= NOW() - INTERVAL '6 months'
GROUP BY DATE_TRUNC('day', updated_at)
ORDER BY date
`

type GetTimeSeriesDataRow struct {
	Date  time.Time `json:"date"`
	Count int64     `json:"count"`
}

func (q *Queries) GetTimeSeriesData(ctx context.Context) ([]GetTimeSeriesDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeSeriesData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeSeriesDataRow
	for rows.Next() {
		var i GetTimeSeriesDataRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importProfile = `-- name: ImportProfile :one
INSERT INTO public.user_profile (facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 1, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
ON CONFLICT (facebook_id) DO UPDATE SET
    name = EXCLUDED.name,
    bio = EXCLUDED.bio,
    location = EXCLUDED.location,
    work = EXCLUDED.work,
    education = EXCLUDED.education,
    relationship_status = EXCLUDED.relationship_status,
    updated_at = EXCLUDED.updated_at,
    is_scanned = EXCLUDED.is_scanned,
    hometown = EXCLUDED.hometown,
    locale = EXCLUDED.locale,
    gender = EXCLUDED.gender,
    birthday = EXCLUDED.birthday,
    email = EXCLUDED.email,
    phone = EXCLUDED.phone,
    profile_url = EXCLUDED.profile_url,
    is_analyzed = EXCLUDED.is_analyzed,
    gemini_score = EXCLUDED.gemini_score
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

type ImportProfileParams struct {
	FacebookID         string          `json:"facebook_id"`
	Name               sql.NullString  `json:"name"`
	Bio                sql.NullString  `json:"bio"`
	Location           sql.NullString  `json:"location"`
	Work               sql.NullString  `json:"work"`
	Education          sql.NullString  `json:"education"`
	RelationshipStatus sql.NullString  `json:"relationship_status"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
	IsScanned          bool            `json:"is_scanned"`
	Hometown           sql.NullString  `json:"hometown"`
	Locale             string          `json:"locale"`
	Gender             sql.NullString  `json:"gender"`
	Birthday           sql.NullString  `json:"birthday"`
	Email              sql.NullString  `json:"email"`
	Phone              sql.NullString  `json:"phone"`
	ProfileUrl         string          `json:"profile_url"`
	IsAnalyzed         sql.NullBool    `json:"is_analyzed"`
	GeminiScore        sql.NullFloat64 `json:"gemini_score"`
}

func (q *Queries) ImportProfile(ctx context.Context, arg ImportProfileParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, importProfile,
		arg.FacebookID,
		arg.Name,
		arg.Bio,
		arg.Location,
		arg.Work,
		arg.Education,
		arg.RelationshipStatus,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsScanned,
		arg.Hometown,
		arg.Locale,
		arg.Gender,
		arg.Birthday,
		arg.Email,
		arg.Phone,
		arg.ProfileUrl,
		arg.IsAnalyzed,
		arg.GeminiScore,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const logAction = `-- name: LogAction :exec
INSERT INTO public.log (account_id, "action", target_id, description, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type LogActionParams struct {
	AccountID   sql.NullInt32  `json:"account_id"`
	Action      string         `json:"action"`
	TargetID    sql.NullInt32  `json:"target_id"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) LogAction(ctx context.Context, arg LogActionParams) error {
	_, err := q.db.ExecContext(ctx, logAction,
		arg.AccountID,
		arg.Action,
		arg.TargetID,
		arg.Description,
	)
	return err
}

const resetProfilesModelScore = `-- name: ResetProfilesModelScore :exec
UPDATE public.user_profile
SET model_score = NULL
`

func (q *Queries) ResetProfilesModelScore(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetProfilesModelScore)
	return err
}

const rollbackPrompt = `-- name: RollbackPrompt :exec
DELETE FROM public.prompt pr WHERE
pr.service_name = $1 AND pr.category_id = $2
AND pr.version = (
  SELECT MAX(version) FROM public.prompt p
  WHERE p.service_name = $1 AND p.category_id = $2
)
`

type RollbackPromptParams struct {
	ServiceName string `json:"service_name"`
	CategoryID  int32  `json:"category_id"`
}

func (q *Queries) RollbackPrompt(ctx context.Context, arg RollbackPromptParams) error {
	_, err := q.db.ExecContext(ctx, rollbackPrompt, arg.ServiceName, arg.CategoryID)
	return err
}

const updateAccountAccessToken = `-- name: UpdateAccountAccessToken :one
UPDATE public.account
SET updated_at = NOW(), access_token = $2
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountAccessTokenParams struct {
	ID          int32          `json:"id"`
	AccessToken sql.NullString `json:"access_token"`
}

func (q *Queries) UpdateAccountAccessToken(ctx context.Context, arg UpdateAccountAccessTokenParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountAccessToken, arg.ID, arg.AccessToken)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateAccountCredentials = `-- name: UpdateAccountCredentials :one
UPDATE public.account
SET updated_at = NOW(),
    email = $2,
    username = $3,
    password = $4
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountCredentialsParams struct {
	ID       int32  `json:"id"`
	Email    string `json:"email"`
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) UpdateAccountCredentials(ctx context.Context, arg UpdateAccountCredentialsParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountCredentials,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE public.category
SET name = $2,
    description = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, updateCategory, arg.ID, arg.Name, arg.Description)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGeminiAnalysisProfile = `-- name: UpdateGeminiAnalysisProfile :one
UPDATE public.user_profile
SET gemini_score = $2,
    is_analyzed = TRUE,
    updated_at = NOW()
WHERE id = $1
RETURNING gemini_score
`

type UpdateGeminiAnalysisProfileParams struct {
	ID          int32           `json:"id"`
	GeminiScore sql.NullFloat64 `json:"gemini_score"`
}

func (q *Queries) UpdateGeminiAnalysisProfile(ctx context.Context, arg UpdateGeminiAnalysisProfileParams) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, updateGeminiAnalysisProfile, arg.ID, arg.GeminiScore)
	var gemini_score sql.NullFloat64
	err := row.Scan(&gemini_score)
	return gemini_score, err
}

const updateGeminiKeyUsage = `-- name: UpdateGeminiKeyUsage :one
UPDATE public.gemini_key
SET token_used = token_used + $2,
updated_at = NOW()
WHERE api_key = $1
RETURNING id, api_key, token_used, updated_at
`

type UpdateGeminiKeyUsageParams struct {
	ApiKey    string `json:"api_key"`
	TokenUsed int64  `json:"token_used"`
}

func (q *Queries) UpdateGeminiKeyUsage(ctx context.Context, arg UpdateGeminiKeyUsageParams) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, updateGeminiKeyUsage, arg.ApiKey, arg.TokenUsed)
	var i GeminiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKey,
		&i.TokenUsed,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroupScannedAt = `-- name: UpdateGroupScannedAt :exec
UPDATE public."group"
SET scanned_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateGroupScannedAt(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, updateGroupScannedAt, id)
	return err
}

const updateModel = `-- name: UpdateModel :one
UPDATE public.model
SET name = $2,
    description = $3,
    category_id = $4
WHERE id = $1
RETURNING id, name, description, created_at, category_id
`

type UpdateModelParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	CategoryID  sql.NullInt32  `json:"category_id"`
}

func (q *Queries) UpdateModel(ctx context.Context, arg UpdateModelParams) (Model, error) {
	row := q.db.QueryRowContext(ctx, updateModel,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CategoryID,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.CategoryID,
	)
	return i, err
}

const updateModelScore = `-- name: UpdateModelScore :exec
UPDATE public.user_profile
SET model_score = $2
WHERE id = $1
`

type UpdateModelScoreParams struct {
	ID         int32           `json:"id"`
	ModelScore sql.NullFloat64 `json:"model_score"`
}

func (q *Queries) UpdateModelScore(ctx context.Context, arg UpdateModelScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateModelScore, arg.ID, arg.ModelScore)
	return err
}

const updateProfileAfterScan = `-- name: UpdateProfileAfterScan :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE,
    bio = $2,
    location = $3,
    work = $4,
    education = $5,
    relationship_status = $6,
    profile_url = $7,
    hometown = $8,
    locale = $9,
    gender = $10,
    birthday = $11,
    email = $12,
    phone = $13
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

type UpdateProfileAfterScanParams struct {
	ID                 int32          `json:"id"`
	Bio                sql.NullString `json:"bio"`
	Location           sql.NullString `json:"location"`
	Work               sql.NullString `json:"work"`
	Education          sql.NullString `json:"education"`
	RelationshipStatus sql.NullString `json:"relationship_status"`
	ProfileUrl         string         `json:"profile_url"`
	Hometown           sql.NullString `json:"hometown"`
	Locale             string         `json:"locale"`
	Gender             sql.NullString `json:"gender"`
	Birthday           sql.NullString `json:"birthday"`
	Email              sql.NullString `json:"email"`
	Phone              sql.NullString `json:"phone"`
}

func (q *Queries) UpdateProfileAfterScan(ctx context.Context, arg UpdateProfileAfterScanParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileAfterScan,
		arg.ID,
		arg.Bio,
		arg.Location,
		arg.Work,
		arg.Education,
		arg.RelationshipStatus,
		arg.ProfileUrl,
		arg.Hometown,
		arg.Locale,
		arg.Gender,
		arg.Birthday,
		arg.Email,
		arg.Phone,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const updateProfileScanStatus = `-- name: UpdateProfileScanStatus :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

func (q *Queries) UpdateProfileScanStatus(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileScanStatus, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const updateRequestStatus = `-- name: UpdateRequestStatus :exec
UPDATE public.request
SET status = $2, updated_at = NOW(), error_message = $3, progress = $4, description = $5
WHERE id = $1
`

type UpdateRequestStatusParams struct {
	ID           int32          `json:"id"`
	Status       int16          `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	Progress     float64        `json:"progress"`
	Description  sql.NullString `json:"description"`
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRequestStatus,
		arg.ID,
		arg.Status,
		arg.ErrorMessage,
		arg.Progress,
		arg.Description,
	)
	return err
}

const upsertConfig = `-- name: UpsertConfig :one
INSERT INTO public.config ("key", "value")
VALUES ($1, $2)
ON CONFLICT ("key") DO UPDATE SET "value" = $2
RETURNING id, key, value
`

type UpsertConfigParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) UpsertConfig(ctx context.Context, arg UpsertConfigParams) (Config, error) {
	row := q.db.QueryRowContext(ctx, upsertConfig, arg.Key, arg.Value)
	var i Config
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const upsertEmbeddedProfiles = `-- name: UpsertEmbeddedProfiles :exec
INSERT INTO public.embedded_profile (pid, embedding, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (pid) DO UPDATE SET
    embedding = EXCLUDED.embedding,
    created_at = NOW()
`

type UpsertEmbeddedProfilesParams struct {
	Pid       int32       `json:"pid"`
	Embedding interface{} `json:"embedding"`
}

func (q *Queries) UpsertEmbeddedProfiles(ctx context.Context, arg UpsertEmbeddedProfilesParams) error {
	_, err := q.db.ExecContext(ctx, upsertEmbeddedProfiles, arg.Pid, arg.Embedding)
	return err
}
