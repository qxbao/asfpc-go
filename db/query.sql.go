// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countGeminiKeys = `-- name: CountGeminiKeys :one
SELECT COUNT(*) as total_gemini_keys FROM public.gemini_key
`

func (q *Queries) CountGeminiKeys(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGeminiKeys)
	var total_gemini_keys int64
	err := row.Scan(&total_gemini_keys)
	return total_gemini_keys, err
}

const countLogs = `-- name: CountLogs :one
SELECT COUNT(*) as total_logs FROM public.log
`

func (q *Queries) CountLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogs)
	var total_logs int64
	err := row.Scan(&total_logs)
	return total_logs, err
}

const countProfiles = `-- name: CountProfiles :one
SELECT COUNT(*) as total_profiles FROM public.user_profile WHERE is_scanned = true
`

func (q *Queries) CountProfiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProfiles)
	var total_profiles int64
	err := row.Scan(&total_profiles)
	return total_profiles, err
}

const countPrompts = `-- name: CountPrompts :one
SELECT COUNT(DISTINCT service_name) as total_prompt FROM public.prompt
`

func (q *Queries) CountPrompts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPrompts)
	var total_prompt int64
	err := row.Scan(&total_prompt)
	return total_prompt, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO public.account (email, username, password, is_block, ua, created_at, updated_at, access_token, proxy_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type CreateAccountParams struct {
	Email       string
	Username    string
	Password    string
	IsBlock     bool
	Ua          string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	AccessToken sql.NullString
	ProxyID     sql.NullInt32
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.IsBlock,
		arg.Ua,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AccessToken,
		arg.ProxyID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO public.comment (post_id, comment_id, content, created_at, author_id, is_analyzed, inserted_at)
VALUES ($1, $2, $3, $4, $5, false, NOW())
RETURNING id, content, is_analyzed, created_at, inserted_at, post_id, author_id, comment_id
`

type CreateCommentParams struct {
	PostID    int32
	CommentID string
	Content   string
	CreatedAt time.Time
	AuthorID  int32
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.PostID,
		arg.CommentID,
		arg.Content,
		arg.CreatedAt,
		arg.AuthorID,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsAnalyzed,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.PostID,
		&i.AuthorID,
		&i.CommentID,
	)
	return i, err
}

const createEmbeddedProfile = `-- name: CreateEmbeddedProfile :one
INSERT INTO public.embedded_profile (pid, embedding, created_at)
VALUES ($1, $2, NOW())
RETURNING id, pid, embedding, created_at
`

type CreateEmbeddedProfileParams struct {
	Pid       int32
	Embedding Vector
}

func (q *Queries) CreateEmbeddedProfile(ctx context.Context, arg CreateEmbeddedProfileParams) (EmbeddedProfile, error) {
	row := q.db.QueryRowContext(ctx, createEmbeddedProfile, arg.Pid, arg.Embedding)
	var i EmbeddedProfile
	err := row.Scan(
		&i.ID,
		&i.Pid,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}

const createGeminiKey = `-- name: CreateGeminiKey :one
INSERT INTO public.gemini_key (api_key)
VALUES ($1)
RETURNING id, api_key, token_used, updated_at
`

func (q *Queries) CreateGeminiKey(ctx context.Context, apiKey string) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, createGeminiKey, apiKey)
	var i GeminiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKey,
		&i.TokenUsed,
		&i.UpdatedAt,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO public."group" (group_id, group_name, is_joined, account_id)
VALUES ($1, $2, false, $3)
RETURNING id, group_id, group_name, is_joined, account_id, scanned_at
`

type CreateGroupParams struct {
	GroupID   string
	GroupName string
	AccountID sql.NullInt32
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.GroupID, arg.GroupName, arg.AccountID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO public.post (post_id, content, created_at, inserted_at, group_id, is_analyzed)
VALUES ($1, $2, $3, NOW(), $4, true)
RETURNING id, post_id, content, created_at, inserted_at, group_id, is_analyzed
`

type CreatePostParams struct {
	PostID    string
	Content   string
	CreatedAt time.Time
	GroupID   int32
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.PostID,
		arg.Content,
		arg.CreatedAt,
		arg.GroupID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO public.user_profile (facebook_id, name, scraped_by_id, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

type CreateProfileParams struct {
	FacebookID  string
	Name        sql.NullString
	ScrapedByID int32
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, createProfile, arg.FacebookID, arg.Name, arg.ScrapedByID)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const createPrompt = `-- name: CreatePrompt :one
WITH next_version AS (
  SELECT COALESCE(MAX(version), 0) + 1 AS version
  FROM public.prompt
  WHERE service_name = $1
)
INSERT INTO public.prompt (service_name, version, content, created_by, created_at)
SELECT $1, next_version.version, $2, $3, NOW()
FROM next_version
RETURNING id, content, service_name, version, created_by, created_at
`

type CreatePromptParams struct {
	ServiceName string
	Content     string
	CreatedBy   string
}

func (q *Queries) CreatePrompt(ctx context.Context, arg CreatePromptParams) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, createPrompt, arg.ServiceName, arg.Content, arg.CreatedBy)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createRequest = `-- name: CreateRequest :one
INSERT INTO public.request(description)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateRequest(ctx context.Context, description sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, createRequest, description)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAccounts = `-- name: DeleteAccounts :exec
DELETE FROM public.account WHERE id = ANY($1::int[])
`

func (q *Queries) DeleteAccounts(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccounts, pq.Array(dollar_1))
	return err
}

const deleteGeminiKey = `-- name: DeleteGeminiKey :exec
DELETE FROM public.gemini_key WHERE id = $1
`

func (q *Queries) DeleteGeminiKey(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGeminiKey, id)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
WITH deleted_posts AS (
  DELETE FROM public.post WHERE group_id = $1 RETURNING post.id
),
deleted_comments AS (
  DELETE FROM public.comment WHERE post_id IN (SELECT id FROM deleted_posts)
)
DELETE FROM public."group" WHERE "group".id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deleteJunkProfiles = `-- name: DeleteJunkProfiles :one
WITH non_null_count AS (
  SELECT up.id,
    (COALESCE(up.bio, '') != '')::int +
    (COALESCE(up.location, '') != '')::int +
    (COALESCE(up.work, '') != '')::int +
    (COALESCE(up.locale, '') != '')::int +
    (COALESCE(up.education, '') != '')::int +
    (COALESCE(up.relationship_status, '') != '')::int +
    (COALESCE(up.hometown, '') != '')::int +
    (COALESCE(up.gender, '') != '')::int +
    (COALESCE(up.birthday, '') != '')::int +
    (COALESCE(up.email, '') != '')::int +
    (COALESCE(up.phone, '') != '')::int AS field_count
  FROM public.user_profile up
),
profiles_to_delete AS (
  SELECT nnc.id 
  FROM non_null_count nnc
  JOIN public.user_profile up ON nnc.id = up.id
  WHERE
    up.is_scanned = true
    AND (up.name = ''
    OR up.name IS NULL
    OR up.name LIKE '%Anonymous%' 
    OR up.name LIKE '%anonymous%' 
    OR up.name LIKE '%ẩn danh%'
    OR up.name LIKE '%Ẩn danh%'
    OR nnc.field_count < 1)
),
deleted_comments AS (
  DELETE FROM public.comment 
  WHERE author_id IN (SELECT id FROM profiles_to_delete)
  RETURNING author_id
),
deleted_profiles AS (
  DELETE FROM public.user_profile 
  WHERE id IN (SELECT id FROM profiles_to_delete)
  RETURNING id
)
SELECT COUNT(*) as deleted_count FROM deleted_profiles
`

func (q *Queries) DeleteJunkProfiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteJunkProfiles)
	var deleted_count int64
	err := row.Scan(&deleted_count)
	return deleted_count, err
}

const findSimilarProfiles = `-- name: FindSimilarProfiles :many
SELECT
  p.id AS profile_id,
  p.profile_url as profile_url,
  p.name AS profile_name,
  CAST(1 - (ep.embedding <=> (
	SELECT embedding FROM public.embedded_profile WHERE embedded_profile.pid = $1
  )) AS DOUBLE PRECISION) AS similarity
FROM embedded_profile ep
JOIN user_profile p ON p.id = ep.pid
WHERE ep.pid != $1
ORDER BY ep.embedding <=> (
	SELECT embedding FROM public.embedded_profile WHERE embedded_profile.pid = $1
  )
LIMIT $2
`

type FindSimilarProfilesParams struct {
	Pid   int32
	Limit int32
}

type FindSimilarProfilesRow struct {
	ProfileID   int32
	ProfileUrl  string
	ProfileName sql.NullString
	Similarity  float64
}

func (q *Queries) FindSimilarProfiles(ctx context.Context, arg FindSimilarProfilesParams) ([]FindSimilarProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, findSimilarProfiles, arg.Pid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindSimilarProfilesRow
	for rows.Next() {
		var i FindSimilarProfilesRow
		if err := rows.Scan(
			&i.ProfileID,
			&i.ProfileUrl,
			&i.ProfileName,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountById = `-- name: GetAccountById :one
SELECT id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id FROM public.account WHERE id = $1
`

func (q *Queries) GetAccountById(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const getAccountStats = `-- name: GetAccountStats :one
SELECT
  (SELECT COUNT(*) FROM public.account) AS total_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = false and access_token IS NOT NULL) AS active_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = true) AS blocked_accounts
`

type GetAccountStatsRow struct {
	TotalAccounts   int64
	ActiveAccounts  int64
	BlockedAccounts int64
}

func (q *Queries) GetAccountStats(ctx context.Context) (GetAccountStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountStats)
	var i GetAccountStatsRow
	err := row.Scan(&i.TotalAccounts, &i.ActiveAccounts, &i.BlockedAccounts)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT a.id, a.username, a.email, a.updated_at, a.access_token, (
	SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id
) as group_count, COOKIES IS NOT NULL as is_login,
a.is_block
FROM public.account a LIMIT $1 OFFSET $2
`

type GetAccountsParams struct {
	Limit  int32
	Offset int32
}

type GetAccountsRow struct {
	ID          int32
	Username    string
	Email       string
	UpdatedAt   time.Time
	AccessToken sql.NullString
	GroupCount  int64
	IsLogin     interface{}
	IsBlock     bool
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]GetAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.GroupCount,
			&i.IsLogin,
			&i.IsBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllConfigs = `-- name: GetAllConfigs :many
SELECT id, key, value FROM public.config
`

func (q *Queries) GetAllConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.db.QueryContext(ctx, getAllConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(&i.ID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPrompts = `-- name: GetAllPrompts :many
SELECT id, content, service_name, version, created_by, created_at, rn
FROM (
  SELECT id, content, service_name, version, created_by, created_at, ROW_NUMBER() OVER (PARTITION BY service_name ORDER BY version DESC) AS rn
  FROM public.prompt
) t
WHERE rn = 1
ORDER BY service_name
LIMIT $1 OFFSET $2
`

type GetAllPromptsParams struct {
	Limit  int32
	Offset int32
}

type GetAllPromptsRow struct {
	ID          int32
	Content     string
	ServiceName string
	Version     int32
	CreatedBy   string
	CreatedAt   time.Time
	Rn          int64
}

func (q *Queries) GetAllPrompts(ctx context.Context, arg GetAllPromptsParams) ([]GetAllPromptsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPrompts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPromptsRow
	for rows.Next() {
		var i GetAllPromptsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.ServiceName,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsToScan = `-- name: GetCommentsToScan :many
SELECT c.id, c.content, c.is_analyzed, c.created_at, c.inserted_at, c.post_id, c.author_id, c.comment_id, a.access_token FROM public.comment c
JOIN public.post p ON c.post_id = p.id
JOIN public."group" g ON p.group_id = g.id
JOIN public.account a ON g.account_id = a.id
WHERE c.is_analyzed = false AND g.account_id = $1
ORDER BY c.inserted_at ASC LIMIT $2
`

type GetCommentsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetCommentsToScanRow struct {
	ID          int32
	Content     string
	IsAnalyzed  bool
	CreatedAt   time.Time
	InsertedAt  time.Time
	PostID      int32
	AuthorID    int32
	CommentID   string
	AccessToken sql.NullString
}

func (q *Queries) GetCommentsToScan(ctx context.Context, arg GetCommentsToScanParams) ([]GetCommentsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsToScanRow
	for rows.Next() {
		var i GetCommentsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsAnalyzed,
			&i.CreatedAt,
			&i.InsertedAt,
			&i.PostID,
			&i.AuthorID,
			&i.CommentID,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfigByKey = `-- name: GetConfigByKey :one
SELECT id, key, value FROM public.config WHERE "key" = $1
`

func (q *Queries) GetConfigByKey(ctx context.Context, key string) (Config, error) {
	row := q.db.QueryRowContext(ctx, getConfigByKey, key)
	var i Config
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const getDashboardStats = `-- name: GetDashboardStats :one

SELECT
  (SELECT COUNT(*) FROM public."group") AS total_groups,
  (SELECT COUNT(*) FROM public.comment) AS total_comments,
  (SELECT COUNT(*) FROM public.post) AS total_posts,
  (SELECT COUNT(*) FROM public.user_profile) AS total_profiles,
  (SELECT COUNT(*) FROM public.embedded_profile) AS embedded_count,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_scanned = true) AS scanned_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE model_score IS NOT NULL) AS scored_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_analyzed = true) AS analyzed_profiles,
  (SELECT COUNT(*) FROM public.account) AS total_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = false and access_token IS NOT NULL) AS active_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = true) AS blocked_accounts
`

type GetDashboardStatsRow struct {
	TotalGroups      int64
	TotalComments    int64
	TotalPosts       int64
	TotalProfiles    int64
	EmbeddedCount    int64
	ScannedProfiles  int64
	ScoredProfiles   int64
	AnalyzedProfiles int64
	TotalAccounts    int64
	ActiveAccounts   int64
	BlockedAccounts  int64
}

// Charts API Queries
func (q *Queries) GetDashboardStats(ctx context.Context) (GetDashboardStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardStats)
	var i GetDashboardStatsRow
	err := row.Scan(
		&i.TotalGroups,
		&i.TotalComments,
		&i.TotalPosts,
		&i.TotalProfiles,
		&i.EmbeddedCount,
		&i.ScannedProfiles,
		&i.ScoredProfiles,
		&i.AnalyzedProfiles,
		&i.TotalAccounts,
		&i.ActiveAccounts,
		&i.BlockedAccounts,
	)
	return i, err
}

const getGeminiKeyForUse = `-- name: GetGeminiKeyForUse :one
SELECT id, api_key, token_used, updated_at FROM public.gemini_key ORDER BY updated_at ASC NULLS FIRST LIMIT 1
`

func (q *Queries) GetGeminiKeyForUse(ctx context.Context) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, getGeminiKeyForUse)
	var i GeminiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKey,
		&i.TokenUsed,
		&i.UpdatedAt,
	)
	return i, err
}

const getGeminiKeys = `-- name: GetGeminiKeys :many
SELECT id, api_key, token_used, updated_at FROM public.gemini_key
`

func (q *Queries) GetGeminiKeys(ctx context.Context) ([]GeminiKey, error) {
	rows, err := q.db.QueryContext(ctx, getGeminiKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeminiKey
	for rows.Next() {
		var i GeminiKey
		if err := rows.Scan(
			&i.ID,
			&i.ApiKey,
			&i.TokenUsed,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupById = `-- name: GetGroupById :one
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE id = $1
`

func (q *Queries) GetGroupById(ctx context.Context, id int32) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupById, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const getGroupByIdWithAccount = `-- name: GetGroupByIdWithAccount :one
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.password, a.email, a.username, a.access_token FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.id = $1
`

type GetGroupByIdWithAccountRow struct {
	ID          int32
	GroupID     string
	GroupName   string
	IsJoined    bool
	AccountID   sql.NullInt32
	ScannedAt   sql.NullTime
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
}

func (q *Queries) GetGroupByIdWithAccount(ctx context.Context, id int32) (GetGroupByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupByIdWithAccount, id)
	var i GetGroupByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const getGroupsByAccountId = `-- name: GetGroupsByAccountId :many
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE account_id = $1
`

func (q *Queries) GetGroupsByAccountId(ctx context.Context, accountID sql.NullInt32) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsToScan = `-- name: GetGroupsToScan :many
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.access_token FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.is_joined = true AND g.account_id = $1
ORDER BY scanned_at ASC NULLS LAST LIMIT $2
`

type GetGroupsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetGroupsToScanRow struct {
	ID          int32
	GroupID     string
	GroupName   string
	IsJoined    bool
	AccountID   sql.NullInt32
	ScannedAt   sql.NullTime
	AccessToken sql.NullString
}

func (q *Queries) GetGroupsToScan(ctx context.Context, arg GetGroupsToScanParams) ([]GetGroupsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsToScanRow
	for rows.Next() {
		var i GetGroupsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogs = `-- name: GetLogs :many
SELECT l.id, l.account_id, l.action, l.target_id, l.description, l.created_at, a.username FROM public.log l
LEFT JOIN public.account a ON l.account_id = a.id
ORDER BY l.created_at DESC
LIMIT $1 OFFSET $2
`

type GetLogsParams struct {
	Limit  int32
	Offset int32
}

type GetLogsRow struct {
	ID          int32
	AccountID   sql.NullInt32
	Action      string
	TargetID    sql.NullInt32
	Description sql.NullString
	CreatedAt   sql.NullTime
	Username    sql.NullString
}

func (q *Queries) GetLogs(ctx context.Context, arg GetLogsParams) ([]GetLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogsRow
	for rows.Next() {
		var i GetLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Action,
			&i.TargetID,
			&i.Description,
			&i.CreatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOKAccountIds = `-- name: GetOKAccountIds :many
SELECT t.id
FROM (SELECT a.id,
  (SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id) AS group_count
  FROM public.account a
  WHERE a.is_block = false AND a.access_token IS NOT NULL
) t
WHERE t.group_count > 0
`

func (q *Queries) GetOKAccountIds(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getOKAccountIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostById = `-- name: GetPostById :one
SELECT id, post_id, content, created_at, inserted_at, group_id, is_analyzed FROM public.post WHERE id = $1
`

func (q *Queries) GetPostById(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostById, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const getPostByIdWithAccount = `-- name: GetPostByIdWithAccount :one
SELECT p.id, p.post_id, p.content, p.created_at, p.inserted_at, p.group_id, p.is_analyzed, a.password, a.email, a.username, a.access_token, a.id AS account_id FROM public.post p
JOIN public."group" g ON p.group_id = g.id
JOIN public.account a ON g.account_id = a.id
WHERE p.id = $1
`

type GetPostByIdWithAccountRow struct {
	ID          int32
	PostID      string
	Content     string
	CreatedAt   time.Time
	InsertedAt  time.Time
	GroupID     int32
	IsAnalyzed  bool
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
	AccountID   int32
}

func (q *Queries) GetPostByIdWithAccount(ctx context.Context, id int32) (GetPostByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByIdWithAccount, id)
	var i GetPostByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
		&i.AccountID,
	)
	return i, err
}

const getPostsToScan = `-- name: GetPostsToScan :many
SELECT p.id, p.post_id, p.content, p.created_at, p.inserted_at, p.group_id, p.is_analyzed, a.access_token FROM public.post p
JOIN "group" g ON p.group_id = g.id
JOIN account a ON g.account_id = a.id
WHERE g.account_id = $1
ORDER BY inserted_at ASC LIMIT $2
`

type GetPostsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetPostsToScanRow struct {
	ID          int32
	PostID      string
	Content     string
	CreatedAt   time.Time
	InsertedAt  time.Time
	GroupID     int32
	IsAnalyzed  bool
	AccessToken sql.NullString
}

func (q *Queries) GetPostsToScan(ctx context.Context, arg GetPostsToScanParams) ([]GetPostsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsToScanRow
	for rows.Next() {
		var i GetPostsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.Content,
			&i.CreatedAt,
			&i.InsertedAt,
			&i.GroupID,
			&i.IsAnalyzed,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileById = `-- name: GetProfileById :one
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score FROM public.user_profile WHERE id = $1
`

func (q *Queries) GetProfileById(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, getProfileById, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const getProfileByIdWithAccount = `-- name: GetProfileByIdWithAccount :one
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, up.is_analyzed, up.gemini_score, up.model_score, a.password, a.email, a.username, a.access_token FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.id = $1
`

type GetProfileByIdWithAccountRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
	ModelScore         sql.NullFloat64
	Password           string
	Email_2            string
	Username           string
	AccessToken        sql.NullString
}

func (q *Queries) GetProfileByIdWithAccount(ctx context.Context, id int32) (GetProfileByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileByIdWithAccount, id)
	var i GetProfileByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
		&i.Password,
		&i.Email_2,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const getProfileEmbedding = `-- name: GetProfileEmbedding :one
SELECT embedding FROM public.embedded_profile WHERE pid = $1
`

func (q *Queries) GetProfileEmbedding(ctx context.Context, pid int32) (Vector, error) {
	row := q.db.QueryRowContext(ctx, getProfileEmbedding, pid)
	var embedding Vector
	err := row.Scan(&embedding)
	return embedding, err
}

const getProfileIDForEmbedding = `-- name: GetProfileIDForEmbedding :many
SELECT id FROM public.user_profile
WHERE id NOT IN (
  SELECT pid FROM public.embedded_profile
) AND is_scanned = true LIMIT $1
`

func (q *Queries) GetProfileIDForEmbedding(ctx context.Context, limit int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getProfileIDForEmbedding, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileStats = `-- name: GetProfileStats :one
SELECT
  (SELECT COUNT(*) FROM public.user_profile) AS total_profiles,
  (SELECT COUNT(*) FROM public.embedded_profile) AS embedded_count,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_scanned = true) AS scanned_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE model_score IS NOT NULL) AS scored_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_analyzed = true) AS analyzed_profiles
`

type GetProfileStatsRow struct {
	TotalProfiles    int64
	EmbeddedCount    int64
	ScannedProfiles  int64
	ScoredProfiles   int64
	AnalyzedProfiles int64
}

func (q *Queries) GetProfileStats(ctx context.Context) (GetProfileStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileStats)
	var i GetProfileStatsRow
	err := row.Scan(
		&i.TotalProfiles,
		&i.EmbeddedCount,
		&i.ScannedProfiles,
		&i.ScoredProfiles,
		&i.AnalyzedProfiles,
	)
	return i, err
}

const getProfilesAnalysisCronjob = `-- name: GetProfilesAnalysisCronjob :many
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score,
  (COALESCE(up.bio, '') != '')::int +
  (COALESCE(up.location, '') != '')::int +
  (COALESCE(up.work, '') != '')::int +
  (COALESCE(up.locale, '') != '')::int +
  (COALESCE(up.education, '') != '')::int +
  (COALESCE(up.relationship_status, '') != '')::int +
  (COALESCE(up.hometown, '') != '')::int +
  (COALESCE(up.gender, '') != '')::int +
  (COALESCE(up.birthday, '') != '')::int +
  (COALESCE(up.email, '') != '')::int +
  (COALESCE(up.phone, '') != '')::int AS non_null_count
FROM public.user_profile up
WHERE up.is_scanned = true AND up.is_analyzed = false
ORDER BY non_null_count DESC, up.updated_at ASC
LIMIT $1
`

type GetProfilesAnalysisCronjobRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
	ModelScore         sql.NullFloat64
	NonNullCount       int32
}

func (q *Queries) GetProfilesAnalysisCronjob(ctx context.Context, limit int32) ([]GetProfilesAnalysisCronjobRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesAnalysisCronjob, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesAnalysisCronjobRow
	for rows.Next() {
		var i GetProfilesAnalysisCronjobRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.NonNullCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesAnalysisPage = `-- name: GetProfilesAnalysisPage :many
SELECT 
  up.id,
  up.facebook_id,
  up.name,
  up.is_analyzed,
  up.gemini_score,
  up.model_score,
  (COALESCE(up.bio, '') != '')::int +
  (COALESCE(up.location, '') != '')::int +
  (COALESCE(up.work, '') != '')::int +
  (COALESCE(up.locale, '') != '')::int +
  (COALESCE(up.education, '') != '')::int +
  (COALESCE(up.relationship_status, '') != '')::int +
  (COALESCE(up.hometown, '') != '')::int +
  (COALESCE(up.gender, '') != '')::int +
  (COALESCE(up.birthday, '') != '')::int +
  (COALESCE(up.email, '') != '')::int +
  (COALESCE(up.phone, '') != '')::int AS non_null_count
FROM public.user_profile up
WHERE up.is_scanned = true
ORDER BY model_score DESC NULLS LAST, gemini_score DESC NULLS LAST, non_null_count DESC, up.updated_at ASC
LIMIT $1 OFFSET $2
`

type GetProfilesAnalysisPageParams struct {
	Limit  int32
	Offset int32
}

type GetProfilesAnalysisPageRow struct {
	ID           int32
	FacebookID   string
	Name         sql.NullString
	IsAnalyzed   sql.NullBool
	GeminiScore  sql.NullFloat64
	ModelScore   sql.NullFloat64
	NonNullCount int32
}

func (q *Queries) GetProfilesAnalysisPage(ctx context.Context, arg GetProfilesAnalysisPageParams) ([]GetProfilesAnalysisPageRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesAnalysisPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesAnalysisPageRow
	for rows.Next() {
		var i GetProfilesAnalysisPageRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.NonNullCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesForExport = `-- name: GetProfilesForExport :many
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, up.is_analyzed, up.gemini_score, up.model_score, ep.embedding FROM public.user_profile up
JOIN public.embedded_profile ep ON up.id = ep.pid
`

type GetProfilesForExportRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
	ModelScore         sql.NullFloat64
	Embedding          Vector
}

func (q *Queries) GetProfilesForExport(ctx context.Context) ([]GetProfilesForExportRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesForExport)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesForExportRow
	for rows.Next() {
		var i GetProfilesForExportRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesForScoring = `-- name: GetProfilesForScoring :many
SELECT up.id FROM public.user_profile up
JOIN public.embedded_profile ep ON up.id = ep.pid
WHERE is_scanned = true AND model_score IS NULL
LIMIT $1
`

func (q *Queries) GetProfilesForScoring(ctx context.Context, limit int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesForScoring, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesToScan = `-- name: GetProfilesToScan :many
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, up.is_analyzed, up.gemini_score, up.model_score, a.access_token, a.id as account_id
FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.is_scanned = false AND a.is_block = false AND a.access_token IS NOT NULL
ORDER BY up.updated_at ASC LIMIT $1
`

type GetProfilesToScanRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
	ModelScore         sql.NullFloat64
	AccessToken        sql.NullString
	AccountID          int32
}

func (q *Queries) GetProfilesToScan(ctx context.Context, limit int32) ([]GetProfilesToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesToScan, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesToScanRow
	for rows.Next() {
		var i GetProfilesToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.ModelScore,
			&i.AccessToken,
			&i.AccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrompt = `-- name: GetPrompt :one
SELECT id, content, service_name, version, created_by, created_at FROM public.prompt
WHERE service_name = $1
ORDER BY version DESC LIMIT 1
`

func (q *Queries) GetPrompt(ctx context.Context, serviceName string) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, getPrompt, serviceName)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getRequestById = `-- name: GetRequestById :one
SELECT id, progress, status, description, created_at, updated_at, error_message FROM public.request WHERE id = $1
`

func (q *Queries) GetRequestById(ctx context.Context, id int32) (Request, error) {
	row := q.db.QueryRowContext(ctx, getRequestById, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Progress,
		&i.Status,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getScoreDistribution = `-- name: GetScoreDistribution :many
WITH scored_profiles AS (
  SELECT
    CASE 
      WHEN gemini_score BETWEEN 0.0 AND 0.2 THEN '0.0-0.2'
      WHEN gemini_score BETWEEN 0.2 AND 0.4 THEN '0.2-0.4'
      WHEN gemini_score BETWEEN 0.4 AND 0.6 THEN '0.4-0.6'
      WHEN gemini_score BETWEEN 0.6 AND 0.8 THEN '0.6-0.8'
      WHEN gemini_score BETWEEN 0.8 AND 1.0 THEN '0.8-1.0'
      ELSE 'unknown'
    END as score_range
  FROM public.user_profile
  WHERE gemini_score IS NOT NULL
)
SELECT
  score_range,
  COUNT(*) as count,
  ROUND((COUNT(*) * 100.0 / (SELECT COUNT(*) FROM public.user_profile WHERE gemini_score IS NOT NULL)), 1) as percentage
FROM scored_profiles
GROUP BY score_range
`

type GetScoreDistributionRow struct {
	ScoreRange string
	Count      int64
	Percentage string
}

func (q *Queries) GetScoreDistribution(ctx context.Context) ([]GetScoreDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getScoreDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoreDistributionRow
	for rows.Next() {
		var i GetScoreDistributionRow
		if err := rows.Scan(&i.ScoreRange, &i.Count, &i.Percentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStats = `-- name: GetStats :one
SELECT
  (SELECT COUNT(*) FROM public."group") AS total_groups,
  (SELECT COUNT(*) FROM public.comment) AS total_comments,
  (SELECT COUNT(*) FROM public.post) AS total_posts
`

type GetStatsRow struct {
	TotalGroups   int64
	TotalComments int64
	TotalPosts    int64
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(&i.TotalGroups, &i.TotalComments, &i.TotalPosts)
	return i, err
}

const getTimeSeriesData = `-- name: GetTimeSeriesData :many
SELECT 
  DATE_TRUNC('month', updated_at)::date as date,
  COUNT(*) as count,
  'scanned_profiles' as data_type
FROM public.user_profile 
WHERE is_scanned = true 
  AND updated_at >= NOW() - INTERVAL '6 months'
GROUP BY DATE_TRUNC('month', updated_at)
ORDER BY date
`

type GetTimeSeriesDataRow struct {
	Date     time.Time
	Count    int64
	DataType string
}

func (q *Queries) GetTimeSeriesData(ctx context.Context) ([]GetTimeSeriesDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeSeriesData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeSeriesDataRow
	for rows.Next() {
		var i GetTimeSeriesDataRow
		if err := rows.Scan(&i.Date, &i.Count, &i.DataType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importProfile = `-- name: ImportProfile :one
INSERT INTO public.user_profile (facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 1, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
ON CONFLICT (facebook_id) DO UPDATE SET
    name = EXCLUDED.name,
    bio = EXCLUDED.bio,
    location = EXCLUDED.location,
    work = EXCLUDED.work,
    education = EXCLUDED.education,
    relationship_status = EXCLUDED.relationship_status,
    updated_at = EXCLUDED.updated_at,
    is_scanned = EXCLUDED.is_scanned,
    hometown = EXCLUDED.hometown,
    locale = EXCLUDED.locale,
    gender = EXCLUDED.gender,
    birthday = EXCLUDED.birthday,
    email = EXCLUDED.email,
    phone = EXCLUDED.phone,
    profile_url = EXCLUDED.profile_url,
    is_analyzed = EXCLUDED.is_analyzed,
    gemini_score = EXCLUDED.gemini_score
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

type ImportProfileParams struct {
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
}

func (q *Queries) ImportProfile(ctx context.Context, arg ImportProfileParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, importProfile,
		arg.FacebookID,
		arg.Name,
		arg.Bio,
		arg.Location,
		arg.Work,
		arg.Education,
		arg.RelationshipStatus,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsScanned,
		arg.Hometown,
		arg.Locale,
		arg.Gender,
		arg.Birthday,
		arg.Email,
		arg.Phone,
		arg.ProfileUrl,
		arg.IsAnalyzed,
		arg.GeminiScore,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const logAction = `-- name: LogAction :exec
INSERT INTO public.log (account_id, "action", target_id, description, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type LogActionParams struct {
	AccountID   sql.NullInt32
	Action      string
	TargetID    sql.NullInt32
	Description sql.NullString
}

func (q *Queries) LogAction(ctx context.Context, arg LogActionParams) error {
	_, err := q.db.ExecContext(ctx, logAction,
		arg.AccountID,
		arg.Action,
		arg.TargetID,
		arg.Description,
	)
	return err
}

const resetProfilesModelScore = `-- name: ResetProfilesModelScore :exec
UPDATE public.user_profile
SET model_score = NULL
`

func (q *Queries) ResetProfilesModelScore(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetProfilesModelScore)
	return err
}

const updateAccountAccessToken = `-- name: UpdateAccountAccessToken :one
UPDATE public.account
SET updated_at = NOW(), access_token = $2
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountAccessTokenParams struct {
	ID          int32
	AccessToken sql.NullString
}

func (q *Queries) UpdateAccountAccessToken(ctx context.Context, arg UpdateAccountAccessTokenParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountAccessToken, arg.ID, arg.AccessToken)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateAccountCredentials = `-- name: UpdateAccountCredentials :one
UPDATE public.account
SET updated_at = NOW(),
    email = $2,
    username = $3,
    password = $4
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountCredentialsParams struct {
	ID       int32
	Email    string
	Username string
	Password string
}

func (q *Queries) UpdateAccountCredentials(ctx context.Context, arg UpdateAccountCredentialsParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountCredentials,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateGeminiAnalysisProfile = `-- name: UpdateGeminiAnalysisProfile :one
UPDATE public.user_profile
SET gemini_score = $2,
    is_analyzed = TRUE,
    updated_at = NOW()
WHERE id = $1
RETURNING gemini_score
`

type UpdateGeminiAnalysisProfileParams struct {
	ID          int32
	GeminiScore sql.NullFloat64
}

func (q *Queries) UpdateGeminiAnalysisProfile(ctx context.Context, arg UpdateGeminiAnalysisProfileParams) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, updateGeminiAnalysisProfile, arg.ID, arg.GeminiScore)
	var gemini_score sql.NullFloat64
	err := row.Scan(&gemini_score)
	return gemini_score, err
}

const updateGeminiKeyUsage = `-- name: UpdateGeminiKeyUsage :one
UPDATE public.gemini_key
SET token_used = token_used + $2,
updated_at = NOW()
WHERE api_key = $1
RETURNING id, api_key, token_used, updated_at
`

type UpdateGeminiKeyUsageParams struct {
	ApiKey    string
	TokenUsed int64
}

func (q *Queries) UpdateGeminiKeyUsage(ctx context.Context, arg UpdateGeminiKeyUsageParams) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, updateGeminiKeyUsage, arg.ApiKey, arg.TokenUsed)
	var i GeminiKey
	err := row.Scan(
		&i.ID,
		&i.ApiKey,
		&i.TokenUsed,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroupScannedAt = `-- name: UpdateGroupScannedAt :exec
UPDATE public."group"
SET scanned_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateGroupScannedAt(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, updateGroupScannedAt, id)
	return err
}

const updateModelScore = `-- name: UpdateModelScore :exec
UPDATE public.user_profile
SET model_score = $2
WHERE id = $1
`

type UpdateModelScoreParams struct {
	ID         int32
	ModelScore sql.NullFloat64
}

func (q *Queries) UpdateModelScore(ctx context.Context, arg UpdateModelScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateModelScore, arg.ID, arg.ModelScore)
	return err
}

const updateProfileAfterScan = `-- name: UpdateProfileAfterScan :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE,
    bio = $2,
    location = $3,
    work = $4,
    education = $5,
    relationship_status = $6,
    profile_url = $7,
    hometown = $8,
    locale = $9,
    gender = $10,
    birthday = $11,
    email = $12,
    phone = $13
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

type UpdateProfileAfterScanParams struct {
	ID                 int32
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	ProfileUrl         string
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
}

func (q *Queries) UpdateProfileAfterScan(ctx context.Context, arg UpdateProfileAfterScanParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileAfterScan,
		arg.ID,
		arg.Bio,
		arg.Location,
		arg.Work,
		arg.Education,
		arg.RelationshipStatus,
		arg.ProfileUrl,
		arg.Hometown,
		arg.Locale,
		arg.Gender,
		arg.Birthday,
		arg.Email,
		arg.Phone,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const updateProfileScanStatus = `-- name: UpdateProfileScanStatus :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url, is_analyzed, gemini_score, model_score
`

func (q *Queries) UpdateProfileScanStatus(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileScanStatus, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.ModelScore,
	)
	return i, err
}

const updateRequestStatus = `-- name: UpdateRequestStatus :exec
UPDATE public.request
SET status = $2, updated_at = NOW(), error_message = $3, progress = $4, description = $5
WHERE id = $1
`

type UpdateRequestStatusParams struct {
	ID           int32
	Status       int16
	ErrorMessage sql.NullString
	Progress     float64
	Description  sql.NullString
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRequestStatus,
		arg.ID,
		arg.Status,
		arg.ErrorMessage,
		arg.Progress,
		arg.Description,
	)
	return err
}

const upsertConfig = `-- name: UpsertConfig :one
INSERT INTO public.config ("key", "value")
VALUES ($1, $2)
ON CONFLICT ("key") DO UPDATE SET "value" = $2
RETURNING id, key, value
`

type UpsertConfigParams struct {
	Key   string
	Value string
}

func (q *Queries) UpsertConfig(ctx context.Context, arg UpsertConfigParams) (Config, error) {
	row := q.db.QueryRowContext(ctx, upsertConfig, arg.Key, arg.Value)
	var i Config
	err := row.Scan(&i.ID, &i.Key, &i.Value)
	return i, err
}

const upsertEmbeddedProfiles = `-- name: UpsertEmbeddedProfiles :exec
INSERT INTO public.embedded_profile (pid, embedding, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT (pid) DO UPDATE SET
    embedding = EXCLUDED.embedding,
    created_at = NOW()
`

type UpsertEmbeddedProfilesParams struct {
	Pid       int32
	Embedding Vector
}

func (q *Queries) UpsertEmbeddedProfiles(ctx context.Context, arg UpsertEmbeddedProfilesParams) error {
	_, err := q.db.ExecContext(ctx, upsertEmbeddedProfiles, arg.Pid, arg.Embedding)
	return err
}
