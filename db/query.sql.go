// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO public.account (email, username, password, is_block, ua, created_at, updated_at, access_token, proxy_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type CreateAccountParams struct {
	Email       string
	Username    string
	Password    string
	IsBlock     bool
	Ua          string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	AccessToken sql.NullString
	ProxyID     sql.NullInt32
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.IsBlock,
		arg.Ua,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AccessToken,
		arg.ProxyID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO public.comment (post_id, comment_id, content, created_at, author_id, is_analyzed, inserted_at)
VALUES ($1, $2, $3, $4, $5, false, NOW())
RETURNING id, content, is_analyzed, created_at, inserted_at, post_id, author_id, comment_id
`

type CreateCommentParams struct {
	PostID    int32
	CommentID string
	Content   string
	CreatedAt time.Time
	AuthorID  int32
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.PostID,
		arg.CommentID,
		arg.Content,
		arg.CreatedAt,
		arg.AuthorID,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsAnalyzed,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.PostID,
		&i.AuthorID,
		&i.CommentID,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO public."group" (group_id, group_name, is_joined, account_id)
VALUES ($1, $2, false, $3)
RETURNING id, group_id, group_name, is_joined, account_id, scanned_at
`

type CreateGroupParams struct {
	GroupID   string
	GroupName string
	AccountID sql.NullInt32
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.GroupID, arg.GroupName, arg.AccountID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO public.post (post_id, content, created_at, inserted_at, group_id, is_analyzed)
VALUES ($1, $2, $3, NOW(), $4, false)
RETURNING id, post_id, content, created_at, inserted_at, group_id, is_analyzed
`

type CreatePostParams struct {
	PostID    string
	Content   string
	CreatedAt time.Time
	GroupID   int32
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.PostID,
		arg.Content,
		arg.CreatedAt,
		arg.GroupID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO public.user_profile (facebook_id, name, scraped_by_id, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

type CreateProfileParams struct {
	FacebookID  string
	Name        sql.NullString
	ScrapedByID int32
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, createProfile, arg.FacebookID, arg.Name, arg.ScrapedByID)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const deleteAccounts = `-- name: DeleteAccounts :exec
DELETE FROM public.account WHERE id = ANY($1::int[])
`

func (q *Queries) DeleteAccounts(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccounts, pq.Array(dollar_1))
	return err
}

const getAccountById = `-- name: GetAccountById :one
SELECT id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id FROM public.account WHERE id = $1
`

func (q *Queries) GetAccountById(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const getAccountStats = `-- name: GetAccountStats :one
SELECT
  (SELECT COUNT(*) FROM public.account) AS total_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = false and access_token IS NOT NULL) AS active_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = true) AS blocked_accounts
`

type GetAccountStatsRow struct {
	TotalAccounts   int64
	ActiveAccounts  int64
	BlockedAccounts int64
}

func (q *Queries) GetAccountStats(ctx context.Context) (GetAccountStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountStats)
	var i GetAccountStatsRow
	err := row.Scan(&i.TotalAccounts, &i.ActiveAccounts, &i.BlockedAccounts)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT a.id, a.username, a.email, a.updated_at, a.access_token, (
	SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id
) as group_count
FROM public.account a LIMIT $1 OFFSET $2
`

type GetAccountsParams struct {
	Limit  int32
	Offset int32
}

type GetAccountsRow struct {
	ID          int32
	Username    string
	Email       string
	UpdatedAt   time.Time
	AccessToken sql.NullString
	GroupCount  int64
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]GetAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.GroupCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllConfigs = `-- name: GetAllConfigs :many
SELECT id, key, value FROM public.config
`

func (q *Queries) GetAllConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.db.QueryContext(ctx, getAllConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(&i.ID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupById = `-- name: GetGroupById :one
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE id = $1
`

func (q *Queries) GetGroupById(ctx context.Context, id int32) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupById, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const getGroupByIdWithAccount = `-- name: GetGroupByIdWithAccount :one
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.password, a.email, a.username, a.access_token FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.id = $1
`

type GetGroupByIdWithAccountRow struct {
	ID          int32
	GroupID     string
	GroupName   string
	IsJoined    bool
	AccountID   sql.NullInt32
	ScannedAt   sql.NullTime
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
}

func (q *Queries) GetGroupByIdWithAccount(ctx context.Context, id int32) (GetGroupByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupByIdWithAccount, id)
	var i GetGroupByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const getGroupsByAccountId = `-- name: GetGroupsByAccountId :many
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE account_id = $1
`

func (q *Queries) GetGroupsByAccountId(ctx context.Context, accountID sql.NullInt32) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostById = `-- name: GetPostById :one
SELECT id, post_id, content, created_at, inserted_at, group_id, is_analyzed FROM public.post WHERE id = $1
`

func (q *Queries) GetPostById(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostById, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const getPostByIdWithAccount = `-- name: GetPostByIdWithAccount :one
SELECT p.id, p.post_id, p.content, p.created_at, p.inserted_at, p.group_id, p.is_analyzed, a.password, a.email, a.username, a.access_token, a.id AS account_id FROM public.post p
JOIN public."group" g ON p.group_id = g.id
JOIN public.account a ON g.account_id = a.id
WHERE p.id = $1
`

type GetPostByIdWithAccountRow struct {
	ID          int32
	PostID      string
	Content     string
	CreatedAt   time.Time
	InsertedAt  time.Time
	GroupID     int32
	IsAnalyzed  bool
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
	AccountID   int32
}

func (q *Queries) GetPostByIdWithAccount(ctx context.Context, id int32) (GetPostByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByIdWithAccount, id)
	var i GetPostByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
		&i.AccountID,
	)
	return i, err
}

const getProfileById = `-- name: GetProfileById :one
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url FROM public.user_profile WHERE id = $1
`

func (q *Queries) GetProfileById(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, getProfileById, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const getProfileByIdWithAccount = `-- name: GetProfileByIdWithAccount :one
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, a.password, a.email, a.username, a.access_token FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.id = $1
`

type GetProfileByIdWithAccountRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	Password           string
	Email_2            string
	Username           string
	AccessToken        sql.NullString
}

func (q *Queries) GetProfileByIdWithAccount(ctx context.Context, id int32) (GetProfileByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileByIdWithAccount, id)
	var i GetProfileByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.Password,
		&i.Email_2,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const updateAccountAccessToken = `-- name: UpdateAccountAccessToken :one
UPDATE public.account
SET updated_at = NOW(), access_token = $2
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountAccessTokenParams struct {
	ID          int32
	AccessToken sql.NullString
}

func (q *Queries) UpdateAccountAccessToken(ctx context.Context, arg UpdateAccountAccessTokenParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountAccessToken, arg.ID, arg.AccessToken)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateAccountCredentials = `-- name: UpdateAccountCredentials :one
UPDATE public.account
SET updated_at = NOW(),
    email = $2,
    username = $3,
    password = $4
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountCredentialsParams struct {
	ID       int32
	Email    string
	Username string
	Password string
}

func (q *Queries) UpdateAccountCredentials(ctx context.Context, arg UpdateAccountCredentialsParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountCredentials,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateGroupScannedAt = `-- name: UpdateGroupScannedAt :exec
UPDATE public."group"
SET scanned_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateGroupScannedAt(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, updateGroupScannedAt, id)
	return err
}

const updateProfileAfterScan = `-- name: UpdateProfileAfterScan :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE,
    bio = $2,
    location = $3,
    work = $4,
    education = $5,
    relationship_status = $6,
    profile_url = $7,
    hometown = $8,
    locale = $9,
    gender = $10,
    birthday = $11,
    email = $12,
    phone = $13
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

type UpdateProfileAfterScanParams struct {
	ID                 int32
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	ProfileUrl         string
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
}

func (q *Queries) UpdateProfileAfterScan(ctx context.Context, arg UpdateProfileAfterScanParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileAfterScan,
		arg.ID,
		arg.Bio,
		arg.Location,
		arg.Work,
		arg.Education,
		arg.RelationshipStatus,
		arg.ProfileUrl,
		arg.Hometown,
		arg.Locale,
		arg.Gender,
		arg.Birthday,
		arg.Email,
		arg.Phone,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}
