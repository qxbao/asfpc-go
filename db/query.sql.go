// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countGeminiKeys = `-- name: CountGeminiKeys :one
SELECT COUNT(*) as total_gemini_keys FROM public.gemini_key
`

func (q *Queries) CountGeminiKeys(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGeminiKeys)
	var total_gemini_keys int64
	err := row.Scan(&total_gemini_keys)
	return total_gemini_keys, err
}

const countLogs = `-- name: CountLogs :one
SELECT COUNT(*) as total_logs FROM public.log
`

func (q *Queries) CountLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLogs)
	var total_logs int64
	err := row.Scan(&total_logs)
	return total_logs, err
}

const countProfiles = `-- name: CountProfiles :one
SELECT COUNT(*) as total_profiles FROM public.user_profile WHERE is_scanned = true
`

func (q *Queries) CountProfiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProfiles)
	var total_profiles int64
	err := row.Scan(&total_profiles)
	return total_profiles, err
}

const countPrompts = `-- name: CountPrompts :one
SELECT COUNT(DISTINCT service_name) as total_prompt FROM public.prompt
`

func (q *Queries) CountPrompts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPrompts)
	var total_prompt int64
	err := row.Scan(&total_prompt)
	return total_prompt, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO public.account (email, username, password, is_block, ua, created_at, updated_at, access_token, proxy_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type CreateAccountParams struct {
	Email       string
	Username    string
	Password    string
	IsBlock     bool
	Ua          string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	AccessToken sql.NullString
	ProxyID     sql.NullInt32
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.IsBlock,
		arg.Ua,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AccessToken,
		arg.ProxyID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO public.comment (post_id, comment_id, content, created_at, author_id, is_analyzed, inserted_at)
VALUES ($1, $2, $3, $4, $5, false, NOW())
RETURNING id, content, is_analyzed, created_at, inserted_at, post_id, author_id, comment_id
`

type CreateCommentParams struct {
	PostID    int32
	CommentID string
	Content   string
	CreatedAt time.Time
	AuthorID  int32
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.PostID,
		arg.CommentID,
		arg.Content,
		arg.CreatedAt,
		arg.AuthorID,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsAnalyzed,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.PostID,
		&i.AuthorID,
		&i.CommentID,
	)
	return i, err
}

const createEmbeddedProfile = `-- name: CreateEmbeddedProfile :one
INSERT INTO public.embedded_profile (pid, embedding, created_at)
VALUES ($1, $2, NOW())
RETURNING id, pid, embedding, created_at
`

type CreateEmbeddedProfileParams struct {
	Pid       int32
	Embedding Vector
}

func (q *Queries) CreateEmbeddedProfile(ctx context.Context, arg CreateEmbeddedProfileParams) (EmbeddedProfile, error) {
	row := q.db.QueryRowContext(ctx, createEmbeddedProfile, arg.Pid, arg.Embedding)
	var i EmbeddedProfile
	err := row.Scan(
		&i.ID,
		&i.Pid,
		&i.Embedding,
		&i.CreatedAt,
	)
	return i, err
}

const createGeminiKey = `-- name: CreateGeminiKey :one
INSERT INTO public.gemini_key (api_key)
VALUES ($1)
RETURNING id, api_key, token_used
`

func (q *Queries) CreateGeminiKey(ctx context.Context, apiKey string) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, createGeminiKey, apiKey)
	var i GeminiKey
	err := row.Scan(&i.ID, &i.ApiKey, &i.TokenUsed)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO public."group" (group_id, group_name, is_joined, account_id)
VALUES ($1, $2, false, $3)
RETURNING id, group_id, group_name, is_joined, account_id, scanned_at
`

type CreateGroupParams struct {
	GroupID   string
	GroupName string
	AccountID sql.NullInt32
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.GroupID, arg.GroupName, arg.AccountID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO public.post (post_id, content, created_at, inserted_at, group_id, is_analyzed)
VALUES ($1, $2, $3, NOW(), $4, true)
RETURNING id, post_id, content, created_at, inserted_at, group_id, is_analyzed
`

type CreatePostParams struct {
	PostID    string
	Content   string
	CreatedAt time.Time
	GroupID   int32
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.PostID,
		arg.Content,
		arg.CreatedAt,
		arg.GroupID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO public.user_profile (facebook_id, name, scraped_by_id, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_analyzed, gemini_score, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

type CreateProfileParams struct {
	FacebookID  string
	Name        sql.NullString
	ScrapedByID int32
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, createProfile, arg.FacebookID, arg.Name, arg.ScrapedByID)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const createPrompt = `-- name: CreatePrompt :one
WITH next_version AS (
  SELECT COALESCE(MAX(version), 0) + 1 AS version
  FROM public.prompt
  WHERE service_name = $1
)
INSERT INTO public.prompt (service_name, version, content, created_by, created_at)
SELECT $1, next_version.version, $2, $3, NOW()
FROM next_version
RETURNING id, content, service_name, version, created_by, created_at
`

type CreatePromptParams struct {
	ServiceName string
	Content     string
	CreatedBy   string
}

func (q *Queries) CreatePrompt(ctx context.Context, arg CreatePromptParams) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, createPrompt, arg.ServiceName, arg.Content, arg.CreatedBy)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAccounts = `-- name: DeleteAccounts :exec
DELETE FROM public.account WHERE id = ANY($1::int[])
`

func (q *Queries) DeleteAccounts(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccounts, pq.Array(dollar_1))
	return err
}

const deleteGeminiKey = `-- name: DeleteGeminiKey :exec
DELETE FROM public.gemini_key WHERE id = $1
`

func (q *Queries) DeleteGeminiKey(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGeminiKey, id)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
WITH deleted_posts AS (
  DELETE FROM public.post WHERE group_id = $1 RETURNING post.id
),
deleted_comments AS (
  DELETE FROM public.comment WHERE post_id IN (SELECT id FROM deleted_posts)
)
DELETE FROM public."group" WHERE "group".id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deleteJunkProfiles = `-- name: DeleteJunkProfiles :one
WITH non_null_count AS (
  SELECT up.id,
    (COALESCE(up.bio, '') != '')::int +
    (COALESCE(up.location, '') != '')::int +
    (COALESCE(up.work, '') != '')::int +
    (COALESCE(up.locale, '') != '')::int +
    (COALESCE(up.education, '') != '')::int +
    (COALESCE(up.relationship_status, '') != '')::int +
    (COALESCE(up.hometown, '') != '')::int +
    (COALESCE(up.gender, '') != '')::int +
    (COALESCE(up.birthday, '') != '')::int +
    (COALESCE(up.email, '') != '')::int +
    (COALESCE(up.phone, '') != '')::int AS field_count
  FROM public.user_profile up
),
profiles_to_delete AS (
  SELECT nnc.id 
  FROM non_null_count nnc
  JOIN public.user_profile up ON nnc.id = up.id
  WHERE
    up.is_scanned = true
    AND (up.name = ''
    OR up.name IS NULL
    OR up.name LIKE '%Anonymous%' 
    OR up.name LIKE '%anonymous%' 
    OR up.name LIKE '%ẩn danh%'
    OR up.name LIKE '%Ẩn danh%'
    OR nnc.field_count < 1)
),
deleted_comments AS (
  DELETE FROM public.comment 
  WHERE author_id IN (SELECT id FROM profiles_to_delete)
  RETURNING author_id
),
deleted_profiles AS (
  DELETE FROM public.user_profile 
  WHERE id IN (SELECT id FROM profiles_to_delete)
  RETURNING id
)
SELECT COUNT(*) as deleted_count FROM deleted_profiles
`

func (q *Queries) DeleteJunkProfiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteJunkProfiles)
	var deleted_count int64
	err := row.Scan(&deleted_count)
	return deleted_count, err
}

const getAccountById = `-- name: GetAccountById :one
SELECT id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id FROM public.account WHERE id = $1
`

func (q *Queries) GetAccountById(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const getAccountStats = `-- name: GetAccountStats :one
SELECT
  (SELECT COUNT(*) FROM public.account) AS total_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = false and access_token IS NOT NULL) AS active_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = true) AS blocked_accounts
`

type GetAccountStatsRow struct {
	TotalAccounts   int64
	ActiveAccounts  int64
	BlockedAccounts int64
}

func (q *Queries) GetAccountStats(ctx context.Context) (GetAccountStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountStats)
	var i GetAccountStatsRow
	err := row.Scan(&i.TotalAccounts, &i.ActiveAccounts, &i.BlockedAccounts)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT a.id, a.username, a.email, a.updated_at, a.access_token, (
	SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id
) as group_count, COOKIES IS NOT NULL as is_login,
a.is_block
FROM public.account a LIMIT $1 OFFSET $2
`

type GetAccountsParams struct {
	Limit  int32
	Offset int32
}

type GetAccountsRow struct {
	ID          int32
	Username    string
	Email       string
	UpdatedAt   time.Time
	AccessToken sql.NullString
	GroupCount  int64
	IsLogin     interface{}
	IsBlock     bool
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]GetAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.GroupCount,
			&i.IsLogin,
			&i.IsBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllConfigs = `-- name: GetAllConfigs :many
SELECT id, key, value FROM public.config
`

func (q *Queries) GetAllConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.db.QueryContext(ctx, getAllConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(&i.ID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPrompts = `-- name: GetAllPrompts :many
SELECT id, content, service_name, version, created_by, created_at, rn
FROM (
  SELECT id, content, service_name, version, created_by, created_at, ROW_NUMBER() OVER (PARTITION BY service_name ORDER BY version DESC) AS rn
  FROM public.prompt
) t
WHERE rn = 1
ORDER BY service_name
LIMIT $1 OFFSET $2
`

type GetAllPromptsParams struct {
	Limit  int32
	Offset int32
}

type GetAllPromptsRow struct {
	ID          int32
	Content     string
	ServiceName string
	Version     int32
	CreatedBy   string
	CreatedAt   time.Time
	Rn          int64
}

func (q *Queries) GetAllPrompts(ctx context.Context, arg GetAllPromptsParams) ([]GetAllPromptsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPrompts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPromptsRow
	for rows.Next() {
		var i GetAllPromptsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.ServiceName,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsToScan = `-- name: GetCommentsToScan :many
SELECT c.id, c.content, c.is_analyzed, c.created_at, c.inserted_at, c.post_id, c.author_id, c.comment_id, a.access_token FROM public.comment c
JOIN public.post p ON c.post_id = p.id
JOIN public."group" g ON p.group_id = g.id
JOIN public.account a ON g.account_id = a.id
WHERE c.is_analyzed = false AND g.account_id = $1
ORDER BY c.inserted_at ASC LIMIT $2
`

type GetCommentsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetCommentsToScanRow struct {
	ID          int32
	Content     string
	IsAnalyzed  bool
	CreatedAt   time.Time
	InsertedAt  time.Time
	PostID      int32
	AuthorID    int32
	CommentID   string
	AccessToken sql.NullString
}

func (q *Queries) GetCommentsToScan(ctx context.Context, arg GetCommentsToScanParams) ([]GetCommentsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsToScanRow
	for rows.Next() {
		var i GetCommentsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsAnalyzed,
			&i.CreatedAt,
			&i.InsertedAt,
			&i.PostID,
			&i.AuthorID,
			&i.CommentID,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeminiKeyForUse = `-- name: GetGeminiKeyForUse :one
SELECT id, api_key, token_used FROM public.gemini_key WHERE token_used = (
  SELECT MIN(token_used) FROM public.gemini_key
) LIMIT 1
`

func (q *Queries) GetGeminiKeyForUse(ctx context.Context) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, getGeminiKeyForUse)
	var i GeminiKey
	err := row.Scan(&i.ID, &i.ApiKey, &i.TokenUsed)
	return i, err
}

const getGeminiKeys = `-- name: GetGeminiKeys :many
SELECT id, api_key, token_used FROM public.gemini_key
`

func (q *Queries) GetGeminiKeys(ctx context.Context) ([]GeminiKey, error) {
	rows, err := q.db.QueryContext(ctx, getGeminiKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeminiKey
	for rows.Next() {
		var i GeminiKey
		if err := rows.Scan(&i.ID, &i.ApiKey, &i.TokenUsed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupById = `-- name: GetGroupById :one
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE id = $1
`

func (q *Queries) GetGroupById(ctx context.Context, id int32) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupById, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const getGroupByIdWithAccount = `-- name: GetGroupByIdWithAccount :one
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.password, a.email, a.username, a.access_token FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.id = $1
`

type GetGroupByIdWithAccountRow struct {
	ID          int32
	GroupID     string
	GroupName   string
	IsJoined    bool
	AccountID   sql.NullInt32
	ScannedAt   sql.NullTime
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
}

func (q *Queries) GetGroupByIdWithAccount(ctx context.Context, id int32) (GetGroupByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupByIdWithAccount, id)
	var i GetGroupByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const getGroupsByAccountId = `-- name: GetGroupsByAccountId :many
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE account_id = $1
`

func (q *Queries) GetGroupsByAccountId(ctx context.Context, accountID sql.NullInt32) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsToScan = `-- name: GetGroupsToScan :many
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.access_token FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.is_joined = true AND g.account_id = $1
ORDER BY scanned_at ASC LIMIT $2
`

type GetGroupsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetGroupsToScanRow struct {
	ID          int32
	GroupID     string
	GroupName   string
	IsJoined    bool
	AccountID   sql.NullInt32
	ScannedAt   sql.NullTime
	AccessToken sql.NullString
}

func (q *Queries) GetGroupsToScan(ctx context.Context, arg GetGroupsToScanParams) ([]GetGroupsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsToScanRow
	for rows.Next() {
		var i GetGroupsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogs = `-- name: GetLogs :many
SELECT l.id, l.account_id, l.action, l.target_id, l.description, l.created_at, a.username FROM public.log l
LEFT JOIN public.account a ON l.account_id = a.id
ORDER BY l.created_at DESC
LIMIT $1 OFFSET $2
`

type GetLogsParams struct {
	Limit  int32
	Offset int32
}

type GetLogsRow struct {
	ID          int32
	AccountID   sql.NullInt32
	Action      string
	TargetID    sql.NullInt32
	Description sql.NullString
	CreatedAt   sql.NullTime
	Username    sql.NullString
}

func (q *Queries) GetLogs(ctx context.Context, arg GetLogsParams) ([]GetLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogsRow
	for rows.Next() {
		var i GetLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Action,
			&i.TargetID,
			&i.Description,
			&i.CreatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOKAccountIds = `-- name: GetOKAccountIds :many
SELECT t.id
FROM (SELECT a.id,
  (SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id) AS group_count
  FROM public.account a
  WHERE a.is_block = false AND a.access_token IS NOT NULL
) t
WHERE t.group_count > 0
`

func (q *Queries) GetOKAccountIds(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getOKAccountIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostById = `-- name: GetPostById :one
SELECT id, post_id, content, created_at, inserted_at, group_id, is_analyzed FROM public.post WHERE id = $1
`

func (q *Queries) GetPostById(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostById, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const getPostByIdWithAccount = `-- name: GetPostByIdWithAccount :one
SELECT p.id, p.post_id, p.content, p.created_at, p.inserted_at, p.group_id, p.is_analyzed, a.password, a.email, a.username, a.access_token, a.id AS account_id FROM public.post p
JOIN public."group" g ON p.group_id = g.id
JOIN public.account a ON g.account_id = a.id
WHERE p.id = $1
`

type GetPostByIdWithAccountRow struct {
	ID          int32
	PostID      string
	Content     string
	CreatedAt   time.Time
	InsertedAt  time.Time
	GroupID     int32
	IsAnalyzed  bool
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
	AccountID   int32
}

func (q *Queries) GetPostByIdWithAccount(ctx context.Context, id int32) (GetPostByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByIdWithAccount, id)
	var i GetPostByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
		&i.AccountID,
	)
	return i, err
}

const getPostsToScan = `-- name: GetPostsToScan :many
SELECT p.id, p.post_id, p.content, p.created_at, p.inserted_at, p.group_id, p.is_analyzed, a.access_token FROM public.post p
JOIN "group" g ON p.group_id = g.id
JOIN account a ON g.account_id = a.id
WHERE g.account_id = $1
ORDER BY inserted_at ASC LIMIT $2
`

type GetPostsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetPostsToScanRow struct {
	ID          int32
	PostID      string
	Content     string
	CreatedAt   time.Time
	InsertedAt  time.Time
	GroupID     int32
	IsAnalyzed  bool
	AccessToken sql.NullString
}

func (q *Queries) GetPostsToScan(ctx context.Context, arg GetPostsToScanParams) ([]GetPostsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsToScanRow
	for rows.Next() {
		var i GetPostsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.Content,
			&i.CreatedAt,
			&i.InsertedAt,
			&i.GroupID,
			&i.IsAnalyzed,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileById = `-- name: GetProfileById :one
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_analyzed, gemini_score, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url FROM public.user_profile WHERE id = $1
`

func (q *Queries) GetProfileById(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, getProfileById, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const getProfileByIdWithAccount = `-- name: GetProfileByIdWithAccount :one
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_analyzed, up.gemini_score, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, a.password, a.email, a.username, a.access_token FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.id = $1
`

type GetProfileByIdWithAccountRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	Password           string
	Email_2            string
	Username           string
	AccessToken        sql.NullString
}

func (q *Queries) GetProfileByIdWithAccount(ctx context.Context, id int32) (GetProfileByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileByIdWithAccount, id)
	var i GetProfileByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.Password,
		&i.Email_2,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const getProfileForEmbedding = `-- name: GetProfileForEmbedding :many
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_analyzed, gemini_score, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url FROM public.user_profile
WHERE is_analyzed = true AND gemini_score IS NOT NULL AND id NOT IN (
  SELECT pid FROM public.embedded_profile
) LIMIT $1
`

func (q *Queries) GetProfileForEmbedding(ctx context.Context, limit int32) ([]UserProfile, error) {
	rows, err := q.db.QueryContext(ctx, getProfileForEmbedding, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProfile
	for rows.Next() {
		var i UserProfile
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileStats = `-- name: GetProfileStats :one
SELECT
  (SELECT COUNT(*) FROM public.user_profile) AS total_profiles,
  (SELECT COUNT(*) FROM public.embedded_profile) AS embedded_count,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_scanned = true) AS scanned_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_analyzed = true) AS analyzed_profiles
`

type GetProfileStatsRow struct {
	TotalProfiles    int64
	EmbeddedCount    int64
	ScannedProfiles  int64
	AnalyzedProfiles int64
}

func (q *Queries) GetProfileStats(ctx context.Context) (GetProfileStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileStats)
	var i GetProfileStatsRow
	err := row.Scan(
		&i.TotalProfiles,
		&i.EmbeddedCount,
		&i.ScannedProfiles,
		&i.AnalyzedProfiles,
	)
	return i, err
}

const getProfilesAnalysisCronjob = `-- name: GetProfilesAnalysisCronjob :many
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_analyzed, gemini_score, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url,
  (COALESCE(up.bio, '') != '')::int +
  (COALESCE(up.location, '') != '')::int +
  (COALESCE(up.work, '') != '')::int +
  (COALESCE(up.locale, '') != '')::int +
  (COALESCE(up.education, '') != '')::int +
  (COALESCE(up.relationship_status, '') != '')::int +
  (COALESCE(up.hometown, '') != '')::int +
  (COALESCE(up.gender, '') != '')::int +
  (COALESCE(up.birthday, '') != '')::int +
  (COALESCE(up.email, '') != '')::int +
  (COALESCE(up.phone, '') != '')::int AS non_null_count
FROM public.user_profile up
WHERE up.is_scanned = true AND up.is_analyzed = false
ORDER BY non_null_count DESC, up.updated_at ASC
LIMIT $1
`

type GetProfilesAnalysisCronjobRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	NonNullCount       int32
}

func (q *Queries) GetProfilesAnalysisCronjob(ctx context.Context, limit int32) ([]GetProfilesAnalysisCronjobRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesAnalysisCronjob, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesAnalysisCronjobRow
	for rows.Next() {
		var i GetProfilesAnalysisCronjobRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.NonNullCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesAnalysisPage = `-- name: GetProfilesAnalysisPage :many
SELECT 
  up.id,
  up.facebook_id,
  up.name,
  up.is_analyzed,
  (COALESCE(up.bio, '') != '')::int +
  (COALESCE(up.location, '') != '')::int +
  (COALESCE(up.work, '') != '')::int +
  (COALESCE(up.locale, '') != '')::int +
  (COALESCE(up.education, '') != '')::int +
  (COALESCE(up.relationship_status, '') != '')::int +
  (COALESCE(up.hometown, '') != '')::int +
  (COALESCE(up.gender, '') != '')::int +
  (COALESCE(up.birthday, '') != '')::int +
  (COALESCE(up.email, '') != '')::int +
  (COALESCE(up.phone, '') != '')::int AS non_null_count
FROM public.user_profile up
WHERE up.is_scanned = true
ORDER BY non_null_count DESC, up.updated_at ASC
LIMIT $1 OFFSET $2
`

type GetProfilesAnalysisPageParams struct {
	Limit  int32
	Offset int32
}

type GetProfilesAnalysisPageRow struct {
	ID           int32
	FacebookID   string
	Name         sql.NullString
	IsAnalyzed   sql.NullBool
	NonNullCount int32
}

func (q *Queries) GetProfilesAnalysisPage(ctx context.Context, arg GetProfilesAnalysisPageParams) ([]GetProfilesAnalysisPageRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesAnalysisPage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesAnalysisPageRow
	for rows.Next() {
		var i GetProfilesAnalysisPageRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.IsAnalyzed,
			&i.NonNullCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesToScan = `-- name: GetProfilesToScan :many
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_analyzed, up.gemini_score, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, a.access_token, a.id as account_id
FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.is_scanned = false AND a.is_block = false AND a.access_token IS NOT NULL
ORDER BY up.updated_at ASC LIMIT $1
`

type GetProfilesToScanRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsAnalyzed         sql.NullBool
	GeminiScore        sql.NullFloat64
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	AccessToken        sql.NullString
	AccountID          int32
}

func (q *Queries) GetProfilesToScan(ctx context.Context, limit int32) ([]GetProfilesToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesToScan, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesToScanRow
	for rows.Next() {
		var i GetProfilesToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsAnalyzed,
			&i.GeminiScore,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.AccessToken,
			&i.AccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrompt = `-- name: GetPrompt :one
SELECT id, content, service_name, version, created_by, created_at FROM public.prompt
WHERE service_name = $1
ORDER BY version DESC LIMIT 1
`

func (q *Queries) GetPrompt(ctx context.Context, serviceName string) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, getPrompt, serviceName)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getStats = `-- name: GetStats :one
SELECT
  (SELECT COUNT(*) FROM public."group") AS total_groups,
  (SELECT COUNT(*) FROM public.comment) AS total_comments,
  (SELECT COUNT(*) FROM public.post) AS total_posts
`

type GetStatsRow struct {
	TotalGroups   int64
	TotalComments int64
	TotalPosts    int64
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(&i.TotalGroups, &i.TotalComments, &i.TotalPosts)
	return i, err
}

const logAction = `-- name: LogAction :exec
INSERT INTO public.log (account_id, "action", target_id, description, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type LogActionParams struct {
	AccountID   sql.NullInt32
	Action      string
	TargetID    sql.NullInt32
	Description sql.NullString
}

func (q *Queries) LogAction(ctx context.Context, arg LogActionParams) error {
	_, err := q.db.ExecContext(ctx, logAction,
		arg.AccountID,
		arg.Action,
		arg.TargetID,
		arg.Description,
	)
	return err
}

const updateAccountAccessToken = `-- name: UpdateAccountAccessToken :one
UPDATE public.account
SET updated_at = NOW(), access_token = $2
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountAccessTokenParams struct {
	ID          int32
	AccessToken sql.NullString
}

func (q *Queries) UpdateAccountAccessToken(ctx context.Context, arg UpdateAccountAccessTokenParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountAccessToken, arg.ID, arg.AccessToken)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateAccountCredentials = `-- name: UpdateAccountCredentials :one
UPDATE public.account
SET updated_at = NOW(),
    email = $2,
    username = $3,
    password = $4
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountCredentialsParams struct {
	ID       int32
	Email    string
	Username string
	Password string
}

func (q *Queries) UpdateAccountCredentials(ctx context.Context, arg UpdateAccountCredentialsParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountCredentials,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateGeminiAnalysisProfile = `-- name: UpdateGeminiAnalysisProfile :one
UPDATE public.user_profile
SET gemini_score = $2,
    is_analyzed = TRUE,
    updated_at = NOW()
WHERE id = $1
RETURNING gemini_score
`

type UpdateGeminiAnalysisProfileParams struct {
	ID          int32
	GeminiScore sql.NullFloat64
}

func (q *Queries) UpdateGeminiAnalysisProfile(ctx context.Context, arg UpdateGeminiAnalysisProfileParams) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, updateGeminiAnalysisProfile, arg.ID, arg.GeminiScore)
	var gemini_score sql.NullFloat64
	err := row.Scan(&gemini_score)
	return gemini_score, err
}

const updateGeminiKeyUsage = `-- name: UpdateGeminiKeyUsage :one
UPDATE public.gemini_key
SET token_used = token_used + $2
WHERE api_key = $1
RETURNING id, api_key, token_used
`

type UpdateGeminiKeyUsageParams struct {
	ApiKey    string
	TokenUsed int64
}

func (q *Queries) UpdateGeminiKeyUsage(ctx context.Context, arg UpdateGeminiKeyUsageParams) (GeminiKey, error) {
	row := q.db.QueryRowContext(ctx, updateGeminiKeyUsage, arg.ApiKey, arg.TokenUsed)
	var i GeminiKey
	err := row.Scan(&i.ID, &i.ApiKey, &i.TokenUsed)
	return i, err
}

const updateGroupScannedAt = `-- name: UpdateGroupScannedAt :exec
UPDATE public."group"
SET scanned_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateGroupScannedAt(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, updateGroupScannedAt, id)
	return err
}

const updateProfileAfterScan = `-- name: UpdateProfileAfterScan :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE,
    bio = $2,
    location = $3,
    work = $4,
    education = $5,
    relationship_status = $6,
    profile_url = $7,
    hometown = $8,
    locale = $9,
    gender = $10,
    birthday = $11,
    email = $12,
    phone = $13
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_analyzed, gemini_score, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

type UpdateProfileAfterScanParams struct {
	ID                 int32
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	ProfileUrl         string
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
}

func (q *Queries) UpdateProfileAfterScan(ctx context.Context, arg UpdateProfileAfterScanParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileAfterScan,
		arg.ID,
		arg.Bio,
		arg.Location,
		arg.Work,
		arg.Education,
		arg.RelationshipStatus,
		arg.ProfileUrl,
		arg.Hometown,
		arg.Locale,
		arg.Gender,
		arg.Birthday,
		arg.Email,
		arg.Phone,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const updateProfileScanStatus = `-- name: UpdateProfileScanStatus :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_analyzed, gemini_score, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

func (q *Queries) UpdateProfileScanStatus(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileScanStatus, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsAnalyzed,
		&i.GeminiScore,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}
