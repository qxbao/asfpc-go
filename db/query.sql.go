// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countPrompts = `-- name: CountPrompts :one
SELECT COUNT(DISTINCT service_name) as total_prompt FROM public.prompt
`

func (q *Queries) CountPrompts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPrompts)
	var total_prompt int64
	err := row.Scan(&total_prompt)
	return total_prompt, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO public.account (email, username, password, is_block, ua, created_at, updated_at, access_token, proxy_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type CreateAccountParams struct {
	Email       string
	Username    string
	Password    string
	IsBlock     bool
	Ua          string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	AccessToken sql.NullString
	ProxyID     sql.NullInt32
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.IsBlock,
		arg.Ua,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AccessToken,
		arg.ProxyID,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO public.comment (post_id, comment_id, content, created_at, author_id, is_analyzed, inserted_at)
VALUES ($1, $2, $3, $4, $5, false, NOW())
RETURNING id, content, is_analyzed, created_at, inserted_at, post_id, author_id, comment_id
`

type CreateCommentParams struct {
	PostID    int32
	CommentID string
	Content   string
	CreatedAt time.Time
	AuthorID  int32
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.PostID,
		arg.CommentID,
		arg.Content,
		arg.CreatedAt,
		arg.AuthorID,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsAnalyzed,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.PostID,
		&i.AuthorID,
		&i.CommentID,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO public."group" (group_id, group_name, is_joined, account_id)
VALUES ($1, $2, false, $3)
RETURNING id, group_id, group_name, is_joined, account_id, scanned_at
`

type CreateGroupParams struct {
	GroupID   string
	GroupName string
	AccountID sql.NullInt32
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.GroupID, arg.GroupName, arg.AccountID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO public.post (post_id, content, created_at, inserted_at, group_id, is_analyzed)
VALUES ($1, $2, $3, NOW(), $4, true)
RETURNING id, post_id, content, created_at, inserted_at, group_id, is_analyzed
`

type CreatePostParams struct {
	PostID    string
	Content   string
	CreatedAt time.Time
	GroupID   int32
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.PostID,
		arg.Content,
		arg.CreatedAt,
		arg.GroupID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const createProfile = `-- name: CreateProfile :one
INSERT INTO public.user_profile (facebook_id, name, scraped_by_id, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

type CreateProfileParams struct {
	FacebookID  string
	Name        sql.NullString
	ScrapedByID int32
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, createProfile, arg.FacebookID, arg.Name, arg.ScrapedByID)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const createPrompt = `-- name: CreatePrompt :one
WITH next_version AS (
  SELECT COALESCE(MAX(version), 0) + 1 AS version
  FROM public.prompt
  WHERE service_name = $1
)
INSERT INTO public.prompt (service_name, version, content, created_by, created_at)
SELECT $1, next_version.version, $2, $3, NOW()
FROM next_version
RETURNING id, content, service_name, version, created_by, created_at
`

type CreatePromptParams struct {
	ServiceName string
	Content     string
	CreatedBy   string
}

func (q *Queries) CreatePrompt(ctx context.Context, arg CreatePromptParams) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, createPrompt, arg.ServiceName, arg.Content, arg.CreatedBy)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAccounts = `-- name: DeleteAccounts :exec
DELETE FROM public.account WHERE id = ANY($1::int[])
`

func (q *Queries) DeleteAccounts(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.ExecContext(ctx, deleteAccounts, pq.Array(dollar_1))
	return err
}

const getAccountById = `-- name: GetAccountById :one
SELECT id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id FROM public.account WHERE id = $1
`

func (q *Queries) GetAccountById(ctx context.Context, id int32) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const getAccountStats = `-- name: GetAccountStats :one
SELECT
  (SELECT COUNT(*) FROM public.account) AS total_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = false and access_token IS NOT NULL) AS active_accounts,
  (SELECT COUNT(*) FROM public.account WHERE is_block = true) AS blocked_accounts
`

type GetAccountStatsRow struct {
	TotalAccounts   int64
	ActiveAccounts  int64
	BlockedAccounts int64
}

func (q *Queries) GetAccountStats(ctx context.Context) (GetAccountStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAccountStats)
	var i GetAccountStatsRow
	err := row.Scan(&i.TotalAccounts, &i.ActiveAccounts, &i.BlockedAccounts)
	return i, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT a.id, a.username, a.email, a.updated_at, a.access_token, (
	SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id
) as group_count, COOKIES IS NOT NULL as is_login
FROM public.account a LIMIT $1 OFFSET $2
`

type GetAccountsParams struct {
	Limit  int32
	Offset int32
}

type GetAccountsRow struct {
	ID          int32
	Username    string
	Email       string
	UpdatedAt   time.Time
	AccessToken sql.NullString
	GroupCount  int64
	IsLogin     interface{}
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]GetAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.GroupCount,
			&i.IsLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllConfigs = `-- name: GetAllConfigs :many
SELECT id, key, value FROM public.config
`

func (q *Queries) GetAllConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.db.QueryContext(ctx, getAllConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(&i.ID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPrompts = `-- name: GetAllPrompts :many
SELECT id, content, service_name, version, created_by, created_at, rn
FROM (
  SELECT id, content, service_name, version, created_by, created_at, ROW_NUMBER() OVER (PARTITION BY service_name ORDER BY version DESC) AS rn
  FROM public.prompt
) t
WHERE rn = 1
ORDER BY service_name
LIMIT $1 OFFSET $2
`

type GetAllPromptsParams struct {
	Limit  int32
	Offset int32
}

type GetAllPromptsRow struct {
	ID          int32
	Content     string
	ServiceName string
	Version     int32
	CreatedBy   string
	CreatedAt   time.Time
	Rn          int64
}

func (q *Queries) GetAllPrompts(ctx context.Context, arg GetAllPromptsParams) ([]GetAllPromptsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPrompts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPromptsRow
	for rows.Next() {
		var i GetAllPromptsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.ServiceName,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsToScan = `-- name: GetCommentsToScan :many
SELECT c.id, c.content, c.is_analyzed, c.created_at, c.inserted_at, c.post_id, c.author_id, c.comment_id, a.access_token FROM public.comment c
JOIN public.post p ON c.post_id = p.id
JOIN public."group" g ON p.group_id = g.id
JOIN public.account a ON g.account_id = a.id
WHERE c.is_analyzed = false AND g.account_id = $1
ORDER BY c.inserted_at ASC LIMIT $2
`

type GetCommentsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetCommentsToScanRow struct {
	ID          int32
	Content     string
	IsAnalyzed  bool
	CreatedAt   time.Time
	InsertedAt  time.Time
	PostID      int32
	AuthorID    int32
	CommentID   string
	AccessToken sql.NullString
}

func (q *Queries) GetCommentsToScan(ctx context.Context, arg GetCommentsToScanParams) ([]GetCommentsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsToScanRow
	for rows.Next() {
		var i GetCommentsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsAnalyzed,
			&i.CreatedAt,
			&i.InsertedAt,
			&i.PostID,
			&i.AuthorID,
			&i.CommentID,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupById = `-- name: GetGroupById :one
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE id = $1
`

func (q *Queries) GetGroupById(ctx context.Context, id int32) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupById, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
	)
	return i, err
}

const getGroupByIdWithAccount = `-- name: GetGroupByIdWithAccount :one
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.password, a.email, a.username, a.access_token FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.id = $1
`

type GetGroupByIdWithAccountRow struct {
	ID          int32
	GroupID     string
	GroupName   string
	IsJoined    bool
	AccountID   sql.NullInt32
	ScannedAt   sql.NullTime
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
}

func (q *Queries) GetGroupByIdWithAccount(ctx context.Context, id int32) (GetGroupByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupByIdWithAccount, id)
	var i GetGroupByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.GroupName,
		&i.IsJoined,
		&i.AccountID,
		&i.ScannedAt,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const getGroupsByAccountId = `-- name: GetGroupsByAccountId :many
SELECT id, group_id, group_name, is_joined, account_id, scanned_at FROM public."group" WHERE account_id = $1
`

func (q *Queries) GetGroupsByAccountId(ctx context.Context, accountID sql.NullInt32) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsToScan = `-- name: GetGroupsToScan :many
SELECT g.id, g.group_id, g.group_name, g.is_joined, g.account_id, g.scanned_at, a.access_token FROM public."group" g
JOIN public.account a ON g.account_id = a.id
WHERE g.is_joined = true AND g.account_id = $1
ORDER BY scanned_at ASC LIMIT $2
`

type GetGroupsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetGroupsToScanRow struct {
	ID          int32
	GroupID     string
	GroupName   string
	IsJoined    bool
	AccountID   sql.NullInt32
	ScannedAt   sql.NullTime
	AccessToken sql.NullString
}

func (q *Queries) GetGroupsToScan(ctx context.Context, arg GetGroupsToScanParams) ([]GetGroupsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsToScanRow
	for rows.Next() {
		var i GetGroupsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.GroupName,
			&i.IsJoined,
			&i.AccountID,
			&i.ScannedAt,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOKAccountIds = `-- name: GetOKAccountIds :many
SELECT t.id
FROM (SELECT a.id,
  (SELECT COUNT(*) FROM public."group" g WHERE g.account_id = a.id) AS group_count
  FROM public.account a
  WHERE a.is_block = false AND a.access_token IS NOT NULL
) t
WHERE t.group_count > 0
`

func (q *Queries) GetOKAccountIds(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getOKAccountIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostById = `-- name: GetPostById :one
SELECT id, post_id, content, created_at, inserted_at, group_id, is_analyzed FROM public.post WHERE id = $1
`

func (q *Queries) GetPostById(ctx context.Context, id int32) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostById, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
	)
	return i, err
}

const getPostByIdWithAccount = `-- name: GetPostByIdWithAccount :one
SELECT p.id, p.post_id, p.content, p.created_at, p.inserted_at, p.group_id, p.is_analyzed, a.password, a.email, a.username, a.access_token, a.id AS account_id FROM public.post p
JOIN public."group" g ON p.group_id = g.id
JOIN public.account a ON g.account_id = a.id
WHERE p.id = $1
`

type GetPostByIdWithAccountRow struct {
	ID          int32
	PostID      string
	Content     string
	CreatedAt   time.Time
	InsertedAt  time.Time
	GroupID     int32
	IsAnalyzed  bool
	Password    string
	Email       string
	Username    string
	AccessToken sql.NullString
	AccountID   int32
}

func (q *Queries) GetPostByIdWithAccount(ctx context.Context, id int32) (GetPostByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByIdWithAccount, id)
	var i GetPostByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.InsertedAt,
		&i.GroupID,
		&i.IsAnalyzed,
		&i.Password,
		&i.Email,
		&i.Username,
		&i.AccessToken,
		&i.AccountID,
	)
	return i, err
}

const getPostsToScan = `-- name: GetPostsToScan :many
SELECT p.id, p.post_id, p.content, p.created_at, p.inserted_at, p.group_id, p.is_analyzed, a.access_token FROM public.post p
JOIN "group" g ON p.group_id = g.id
JOIN account a ON g.account_id = a.id
WHERE g.account_id = $1
ORDER BY inserted_at ASC LIMIT $2
`

type GetPostsToScanParams struct {
	AccountID sql.NullInt32
	Limit     int32
}

type GetPostsToScanRow struct {
	ID          int32
	PostID      string
	Content     string
	CreatedAt   time.Time
	InsertedAt  time.Time
	GroupID     int32
	IsAnalyzed  bool
	AccessToken sql.NullString
}

func (q *Queries) GetPostsToScan(ctx context.Context, arg GetPostsToScanParams) ([]GetPostsToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsToScan, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsToScanRow
	for rows.Next() {
		var i GetPostsToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.Content,
			&i.CreatedAt,
			&i.InsertedAt,
			&i.GroupID,
			&i.IsAnalyzed,
			&i.AccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileById = `-- name: GetProfileById :one
SELECT id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url FROM public.user_profile WHERE id = $1
`

func (q *Queries) GetProfileById(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, getProfileById, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const getProfileByIdWithAccount = `-- name: GetProfileByIdWithAccount :one
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, a.password, a.email, a.username, a.access_token FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.id = $1
`

type GetProfileByIdWithAccountRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	Password           string
	Email_2            string
	Username           string
	AccessToken        sql.NullString
}

func (q *Queries) GetProfileByIdWithAccount(ctx context.Context, id int32) (GetProfileByIdWithAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileByIdWithAccount, id)
	var i GetProfileByIdWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
		&i.Password,
		&i.Email_2,
		&i.Username,
		&i.AccessToken,
	)
	return i, err
}

const getProfilesToScan = `-- name: GetProfilesToScan :many
SELECT up.id, up.facebook_id, up.name, up.bio, up.location, up.work, up.education, up.relationship_status, up.created_at, up.updated_at, up.scraped_by_id, up.is_scanned, up.hometown, up.locale, up.gender, up.birthday, up.email, up.phone, up.profile_url, a.access_token, a.id as account_id
FROM public.user_profile up
JOIN public.account a ON up.scraped_by_id = a.id
WHERE up.is_scanned = false AND a.is_block = false AND a.access_token IS NOT NULL
ORDER BY up.updated_at ASC LIMIT $1
`

type GetProfilesToScanRow struct {
	ID                 int32
	FacebookID         string
	Name               sql.NullString
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ScrapedByID        int32
	IsScanned          bool
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
	ProfileUrl         string
	AccessToken        sql.NullString
	AccountID          int32
}

func (q *Queries) GetProfilesToScan(ctx context.Context, limit int32) ([]GetProfilesToScanRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesToScan, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfilesToScanRow
	for rows.Next() {
		var i GetProfilesToScanRow
		if err := rows.Scan(
			&i.ID,
			&i.FacebookID,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.Work,
			&i.Education,
			&i.RelationshipStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScrapedByID,
			&i.IsScanned,
			&i.Hometown,
			&i.Locale,
			&i.Gender,
			&i.Birthday,
			&i.Email,
			&i.Phone,
			&i.ProfileUrl,
			&i.AccessToken,
			&i.AccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrompt = `-- name: GetPrompt :one
SELECT id, content, service_name, version, created_by, created_at FROM public.prompt
WHERE service_name = $1
ORDER BY version DESC LIMIT 1
`

func (q *Queries) GetPrompt(ctx context.Context, serviceName string) (Prompt, error) {
	row := q.db.QueryRowContext(ctx, getPrompt, serviceName)
	var i Prompt
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ServiceName,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getStats = `-- name: GetStats :one
SELECT
  (SELECT COUNT(*) FROM public.user_profile) AS total_profiles,
  (SELECT COUNT(*) FROM public.user_profile WHERE is_scanned = true) AS scanned_profiles,
  (SELECT COUNT(*) FROM public."group") AS total_groups,
  (SELECT COUNT(*) FROM public.comment) AS total_comments,
  (SELECT COUNT(*) FROM public.post) AS total_posts
`

type GetStatsRow struct {
	TotalProfiles   int64
	ScannedProfiles int64
	TotalGroups     int64
	TotalComments   int64
	TotalPosts      int64
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(
		&i.TotalProfiles,
		&i.ScannedProfiles,
		&i.TotalGroups,
		&i.TotalComments,
		&i.TotalPosts,
	)
	return i, err
}

const logAction = `-- name: LogAction :exec
INSERT INTO public.log (account_id, "action", target_id, description, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type LogActionParams struct {
	AccountID   sql.NullInt32
	Action      string
	TargetID    sql.NullInt32
	Description sql.NullString
}

func (q *Queries) LogAction(ctx context.Context, arg LogActionParams) error {
	_, err := q.db.ExecContext(ctx, logAction,
		arg.AccountID,
		arg.Action,
		arg.TargetID,
		arg.Description,
	)
	return err
}

const updateAccountAccessToken = `-- name: UpdateAccountAccessToken :one
UPDATE public.account
SET updated_at = NOW(), access_token = $2
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountAccessTokenParams struct {
	ID          int32
	AccessToken sql.NullString
}

func (q *Queries) UpdateAccountAccessToken(ctx context.Context, arg UpdateAccountAccessTokenParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountAccessToken, arg.ID, arg.AccessToken)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateAccountCredentials = `-- name: UpdateAccountCredentials :one
UPDATE public.account
SET updated_at = NOW(),
    email = $2,
    username = $3,
    password = $4
WHERE id = $1
RETURNING id, email, username, password, is_block, ua, created_at, updated_at, cookies, access_token, proxy_id
`

type UpdateAccountCredentialsParams struct {
	ID       int32
	Email    string
	Username string
	Password string
}

func (q *Queries) UpdateAccountCredentials(ctx context.Context, arg UpdateAccountCredentialsParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, updateAccountCredentials,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.IsBlock,
		&i.Ua,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cookies,
		&i.AccessToken,
		&i.ProxyID,
	)
	return i, err
}

const updateGroupScannedAt = `-- name: UpdateGroupScannedAt :exec
UPDATE public."group"
SET scanned_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateGroupScannedAt(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, updateGroupScannedAt, id)
	return err
}

const updateProfileAfterScan = `-- name: UpdateProfileAfterScan :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE,
    bio = $2,
    location = $3,
    work = $4,
    education = $5,
    relationship_status = $6,
    profile_url = $7,
    hometown = $8,
    locale = $9,
    gender = $10,
    birthday = $11,
    email = $12,
    phone = $13
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

type UpdateProfileAfterScanParams struct {
	ID                 int32
	Bio                sql.NullString
	Location           sql.NullString
	Work               sql.NullString
	Education          sql.NullString
	RelationshipStatus sql.NullString
	ProfileUrl         string
	Hometown           sql.NullString
	Locale             string
	Gender             sql.NullString
	Birthday           sql.NullString
	Email              sql.NullString
	Phone              sql.NullString
}

func (q *Queries) UpdateProfileAfterScan(ctx context.Context, arg UpdateProfileAfterScanParams) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileAfterScan,
		arg.ID,
		arg.Bio,
		arg.Location,
		arg.Work,
		arg.Education,
		arg.RelationshipStatus,
		arg.ProfileUrl,
		arg.Hometown,
		arg.Locale,
		arg.Gender,
		arg.Birthday,
		arg.Email,
		arg.Phone,
	)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}

const updateProfileScanStatus = `-- name: UpdateProfileScanStatus :one
UPDATE public.user_profile
SET updated_at = NOW(),
    is_scanned = TRUE
WHERE id = $1
RETURNING id, facebook_id, name, bio, location, work, education, relationship_status, created_at, updated_at, scraped_by_id, is_scanned, hometown, locale, gender, birthday, email, phone, profile_url
`

func (q *Queries) UpdateProfileScanStatus(ctx context.Context, id int32) (UserProfile, error) {
	row := q.db.QueryRowContext(ctx, updateProfileScanStatus, id)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.FacebookID,
		&i.Name,
		&i.Bio,
		&i.Location,
		&i.Work,
		&i.Education,
		&i.RelationshipStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScrapedByID,
		&i.IsScanned,
		&i.Hometown,
		&i.Locale,
		&i.Gender,
		&i.Birthday,
		&i.Email,
		&i.Phone,
		&i.ProfileUrl,
	)
	return i, err
}
